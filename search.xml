<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试常见问题整理]]></title>
    <url>%2F2019%2F08%2F01%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java中的异常Error也是继承自 Throwable!!!* 抛出Error时，(其实与 exception一样)只要有Catch能接住,程序就不会崩！(当然此时catch只能 *用 *catch(Throwable t | Error e)才能catch住！ 没catch住当然会崩！)，有finnal语句 final语句一样会执行！ 执行完后程序才会再崩。 异常的体系结构如下： 只要进入try-catch-finally块， 任何环境下。 finally中的语句一定会执行！ Thorwable类（表示可抛出）是所有异常和错误的超类，两个直接子类为Error和Exception，分别表示错误和异常。其中异常类Exception又分为运行时异常(RuntimeException)和非运行时异常， 这两种异常有很大的区别，也称之为不检查异常（Unchecked Exception）和检查异常（Checked Exception）。下面将详细讲述这些异常之间的区别与联系：1、Error与Exception Error是程序无法处理的错误，它是由JVM产生和抛出的，比如OutOfMemoryError、ThreadDeath等。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。(注意:能被catch住不做处理，程序也会正常运行下去) Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。程序中应当尽可能去处理这些异常。注意：博主当时的错误也就出在这里 Error是程序无法处理的错误！ 一直是这样认为的，就认为程序只要抛除Error，程序一定会崩。 然而 没想到 抛出的Error也能被catch住。按照 异常的处理规则，父类是能catch住其子类类型的异常的！！！ 而不管你是Error还是Exception，Throwable都能接住，因为是 Error与Exception的父类） 2、运行时异常和非运行时异常 运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常(编译时就能检查出来)是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。(通俗点讲，这种异常，ide开发工具一般都会提醒你要catch！)如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 3、 try、catch、finally三个语句块应注意的问题 第一：try、catch、finally三个语句块均不能单独使用，三者可以组成 try…catch…finally、try…catch、try…finally三种结构，catch语句可以有一个或多个，finally语句最多一个。 第二：try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。 第三：多个catch块时候，最多只会匹配其中一个异常类且只会执行该catch块代码，而不会再执行其它的catch块，且匹配catch语句的顺序为从上到下，也可能所有的catch都没执行。 第四： 先Catch子类异常再Catch父类异常。 TCP三次握手三次握手示意图: 三次 是确保双方都有接收/发送能力 的最小次数！ Http请求常见状态码 类别 含义 1XX Information（信息性状态码） 请求正在处理 2XX Success(成功状态码) 请求正常处理完成 3XX Redirection(重定向状态码) 4XX Client Error(客户端错误) 5XX Server Error(服务器状态码) 常见几个:（面试备用）200 OK 请求完全成功 204 No Content (请求成功，但是没有返回任何主体，此时页面不用刷新)301 Moved Permanently 永久重定向 302 Found 临时重定向400 Bad Request 请求存在语法错误 401 Unauthorized 无权访问403 Forbidden 不允许访问请求的资源 404 Not Found 未找到请求页面500 Internal Server Error 服务器错误 503 Service Unbelievable 服务器超负荷 或者 停机维护无法对外界 提供服务你 Http请求种类记个五种 先: GET POST DELETE PUT TRACE(回显服务器收到的请求，主要用于测试或诊断) CONNECT # ThreadLocal 面试题:确保线程安全 有哪几种方式？ 1.尽量使用局部变量(在方法内，也就绝对线程安全啦)2.使用ThreadLocal,为每个线程单独存储变量.(有高手也可以给我补充补充啊，或者执正一下) ThreadLocal一般称为线程本地变量，它是一种特殊的线程绑定机制，将变量与线程绑定在一起，为每一个线程维护一个独立的变量副本。通过ThreadLocal可以将对象的可见范围限制在同一个线程内。 而ThreadLocal将变量绑定在线程上，在一个线程周期内，无论“你身处何地”，只需通过其提供的get方法就可轻松获取到对象。极大地提高了对于线程级变量的访问便利性。 12345678910//ThreadLocal的set操作public void set(T value) &#123; Thread t = Thread.currentThread();//1.首先获取当前线程对象 ThreadLocalMap map = getMap(t);//2.获取该线程对象的ThreadLocalMap if (map != null) map.set(this, value);//如果map不为空，执行set操作，以当前threadLocal对象为 key，实际存储对象为value进行set操作 else createMap(t, value);//如果map为空，则为该线程创建ThreadLocalMap &#125;//ThreadLocal是个入口，真正的变量是绑定在 线程上的 Thread类中的定义，每个线程对象都拥有一个ThreadLocalMap对象。 1234567891011121314151617181920212223 /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;static class ThreadLocalMap &#123; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. * 总是以ThreadLocal对象作为key。该key也可能为空，意味着这个key已不再被使用 */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; 1.ThreadLocal仅仅是个变量访问的入口； 2.每一个Thread对象都有一个ThreadLocalMap对象，这个ThreadLocalMap持有对象的引用； 3.ThreadLocalMap以当前的threadlocal对象为key，以真正的存储对象为value。get时通过threadlocal实例就可以找到绑定在当前线程上的对象 TOP K问题方式一：堆排序 (O(nlg(k)))先用前ｋ个元素 构建一个*最小堆**， 接下来就是 堆排序了。最终该堆中的元素 就是top k了。(数据量少 可以) 堆排序：n logn堆： 一个二叉树： 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆 大顶堆：arr[i] &gt;= arr[2i+1] &amp;&amp; arr[i] &gt;= arr[2i+2] 小顶堆：arr[i] &lt;= arr[2i+1] &amp;&amp; arr[i] &lt;= arr[2i+2] 基本思路： a. 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; b. 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 （具体构建堆 的过程自行参考算法） 希尔排序一句话： 插入排序的改进版。gap不断缩小 两边交换，最终变为1则排序完成 桶排序一个萝卜一个坑，萝卜放在它应该在的坑。(对数据规模小，且数字不大的 数序列 很友好！) 数组中找出两数之和：O(n)关键问题在于找差值的是偶，能O(1)找出想要的数。—-所以，需要借助 (Java)HashMap来进行查找. 12345678// 一遍HashMap，在插入时 就查找for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return int[map.get(complement)]; //找到则 直接取出该key的value就行 &#125; map.put(nums[i], i); //没找到就将数据 放入 map即可 &#125; String 对象 String s = “abcd” 与 String s1 = new String(“abcd”) 是两种不一样的创建方式 对于==，如果作用于基本数据类型的变量，则直接比较其存储的值是否相等； 如果作用于引用类型的变量，则比较的是所指向的对象的地址 （因为 new 生成的是两个对象，其内存地址不同） 所以 str3 != str4 new出来的字符串和直接赋值给变量的字符串存放的位置是不一样的，前者是在堆里面，而后者在常量池里面 切记： 通过new生成的对象，其值永远 是不相等的！ 非new生成的，其值均放在常量池！记住这两个重要的区别。 String虽然是一个 int 与 Integerint与Integer 用 == 进行比较时，比较的是值！ (非引用值) Integer 与 Interger用 == 进行比较时，则比较的是 引用值！ Java定义在自动装箱时对于值从–128 到127 之间的值，它们被装箱为 Integer 对象后，会存在内存中被重用，始终只存在一个对象。 但是,仅限于 非new产生的Integer 对象，他们会共用一个。 new产生的对象，则 不会去用那些缓存的Integer对象 。 new 与 非new 的Integer用 == 进行比较，永远不同。 123456789private static class IntegerCache &#123; //Integer内部类 //享元模式 -128~127 static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; 1234567891011121314151617Integer i1 = 13;Integer i2 = Integer.valueOf(13);Integer i21 = Integer.valueOf(13);Integer i3 = new Integer(13);Integer i31 = new Integer(13);System.out.println(i1 == i2); //trueSystem.out.println(i21 == i2); // true i1 i2 i21 共享同一个 13System.out.println(i3 == i2); //false new出来的，完全是一个新对象System.out.println(i3 == i31); //fasle new出来的，完全是一个新对象Integer i4 = 520;Integer i5 = Integer.valueOf(520);Integer i51 = Integer.valueOf(520);Integer i6 = new Integer(520);System.out.println(i4 == i5); //fasleSystem.out.println(i5 == i51); //false i4 i5 i51 超过-128~127的范围了，不在共享了System.out.println(i5 == i6); //false new出来的，当然是完全不同的对象 ConcurrentHahMap与 HashMap前者大量使用 Unsafe类的操作 U.compareAndSwapXXX的方法这个方法是利用一个CAS算法实现无锁化的修改值的操作，他可以大大降低锁代理的性能消耗。。 以及分段锁(好像都不是这么说的，只要知道是锁 细化，只锁住链表/红黑树 的开头节点，而非给整个HashMap加锁) 读取文件并将其输入到控制台面试时要是写这种，千万 千万 千万 不要去想什么编码格式， 按普通的写就行了！！！ 123456789public void test() throws FileNotFoundException,IOException &#123; FileInputStream fileInputStream = new FileInputStream("1.txt"); byte[] bytes = new byte[1024]; int i; while ((i = fileInputStream.read(bytes)) != -1)&#123; System.out.println(new String(bytes,0,i)); &#125;&#125;//文件放在与src平级的位置即可 MySQL的各种JOINinner join：也就是 默认的join， 查出的是两边共有的 left join：以左边为主，右边的有些记录可能没有 right join： 以右边为主，左边 的有些记录可能没有 full join：两边全有！(MySQ不支持， 但是可以通过 left join+ union+right join实现. Oracle支持FUll JOIN) (不要 把inner jion 和 full join 记反了) Java中的main函数main函数格式固定！ 哪儿都不能改！ 否则程序无法正常启动！！！(要是问你原因，就是jvm就是这么设计的,然后你可以告诉他 可以从盘古开天辟地开始问的 ) main 函数可以重载！！！ 可以自己在里面调用自己(当然这样会爆栈)！！！ (被个啥奇奇怪怪的面试的问到过这种奇葩问题，真蛋疼………..还有啥 对象和实例 有什么区别？整懵逼了…….阿三和印度的人的区别！) Java 中传值 OR 传址？When you’re passing primitives into a method, you get a distinct copy of the primitive. When you’re passing a reference into a method, you get a copy of the reference.—《Thingking In Java》 Java中传递的永远是 传递对象的副本！ 12345678910111213141516171819202122232425262728293031323334353637package com.xuren.interview;public class StringAndChar &#123; String string = new String("good"); StringBuilder stringBuilder = new StringBuilder("hello"); StringBuilder stringBuilder1 = new StringBuilder("hello1"); char[] ch=&#123;'a','b','c'&#125;; public static void main(String[] args) &#123; StringAndChar ex = new StringAndChar(); ex.change(ex.string,ex.ch ); System.out.println(ex.string+"and"); // goodand System.out.println(ex.ch);// g bc ex.changeBuilder(ex.stringBuilder,ex.stringBuilder1); System.out.println(ex.stringBuilder); // hello are you ok? System.out.println(ex.stringBuilder1);// hello1 &#125; public void change(String s,char ch[])&#123; s = "test ok"; ch[0] = 'g'; &#125; public void changeBuilder(StringBuilder s,StringBuilder s1)&#123; s.append("are you ok?"); s1=s; &#125;&#125;//对于所用基本数据与对象，传递的都是 副本！ 在函数内对副本的任何改变 都不会反应到本体上！//要想让函数达成改变效果(只针对引用)，必须要将 该改变后的副本 传回去！即 一定要有返回值 将这种改变返回！/** 特殊情况*String类，由于其不可变性，就算将 改变后的值返回 以及 调用其内部函数等，原值 也是无法改变的！*StringBiulder/Buffer 调用其 内部append()函数等，就算不返回，原值也是可以改变的！*其他对象也是，调用其内部函数后，就算不返回，一样可以改变本体值！*/ 如何通过 函数交换 两个int数据的值目前只想到 投机取巧的方法,将其 封装到 int[] 中作为交换函数的 参数，其他暂时没想到。 POST 与 GET 区别参考博文 大概记住:只要不是密文传输，没有谁更安全。 (POST稍微安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。)GET长度限制 主要是 URL地址不能过长。 POST可传递二进制数据， GET不能。GET能被收藏，能被作为书签，能被缓存，历史记录可以查到，后退按钮/刷新按钮无害。 但是POST统统不行。 Java中的 父子类继承若 子类中有与 父类 同名通类型的成员变量，则使用子类new的对象时， 子类中的该变量会完全取代 父类的该成员变量，且父类的改变量 若没有重新指定值时，该变量也会自动变为NULL。 12345678910111213141516171819202122232425262728293031323334353637//父public class Base &#123; private String string = "base"; Base()&#123; basePrint(); &#125; public void basePrint() &#123; System.out.println(string); &#125;&#125;// 子public class Sub extends Base &#123; private String string = "Sub"; Sub()&#123; basePrint(); &#125; public void basePrint() &#123; System.out.println(string); &#125;&#125;//测试类public class SubTest &#123; public static void main(String[] args) &#123; Base a = new Sub(); &#125;&#125;//输出结果:// null (子类初始化 当然是先初始化父类，父类中与子类同名[只 同名即可]的对象 置为NULL[若子类对象中的 同名变量类型变为 数值类型，则是变为0，父类中该成员变脸 类型不用管！] )// Sub (输出子类中的 成员变量的值)]]></content>
      <categories>
        <category>面试问题整理</category>
      </categories>
      <tags>
        <tag>面试问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机英语单词学习]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[ABCDEequivalent (to) 等加的，等同的; extract 提取，摘录，开方，求根；摘录，引文; FGHIJKLMmutable 可变的，易变的; NOPQRSTUVWXYZ]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>计算机专业英文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中String类详解]]></title>
    <url>%2F2019%2F07%2F31%2FJava%E4%B8%ADString%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[String以下为Java中String类 源码，注释 翻译自 源码中的注释(会夹杂自己遇见的面试点等东西)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725172617271728172917301731173217331734173517361737173817391740174117421743174417451746174717481749175017511752175317541755175617571758175917601761176217631764176517661767176817691770177117721773177417751776177717781779178017811782178317841785178617871788178917901791179217931794179517961797179817991800180118021803180418051806180718081809181018111812181318141815181618171818181918201821182218231824182518261827182818291830183118321833183418351836183718381839184018411842184318441845184618471848184918501851185218531854185518561857185818591860186118621863186418651866186718681869187018711872187318741875187618771878187918801881188218831884188518861887188818891890189118921893189418951896189718981899190019011902190319041905190619071908190919101911191219131914191519161917191819191920192119221923192419251926192719281929193019311932193319341935193619371938193919401941194219431944194519461947194819491950195119521953195419551956195719581959196019611962196319641965196619671968196919701971197219731974197519761977197819791980198119821983198419851986198719881989199019911992199319941995199619971998199920002001200220032004200520062007200820092010201120122013201420152016201720182019202020212022202320242025202620272028202920302031203220332034203520362037203820392040204120422043204420452046204720482049205020512052205320542055205620572058205920602061206220632064206520662067206820692070207120722073207420752076207720782079208020812082208320842085208620872088208920902091209220932094209520962097209820992100210121022103210421052106210721082109211021112112211321142115211621172118211921202121212221232124212521262127212821292130213121322133213421352136213721382139214021412142214321442145214621472148214921502151215221532154215521562157215821592160216121622163216421652166216721682169217021712172217321742175217621772178217921802181218221832184218521862187218821892190219121922193219421952196219721982199220022012202220322042205220622072208220922102211221222132214221522162217221822192220222122222223222422252226222722282229223022312232223322342235223622372238223922402241224222432244224522462247224822492250225122522253225422552256225722582259226022612262226322642265226622672268226922702271227222732274227522762277227822792280228122822283228422852286228722882289229022912292229322942295229622972298229923002301230223032304230523062307230823092310231123122313231423152316231723182319232023212322232323242325232623272328232923302331233223332334package java.lang;/** *String类表示字符 串。Java程序中所有的 串字面量 例如"abc" ,都是 该类的一个实例 * 字符串是 常量，在被创建 其值就不能被改变。 因为Strind对象是不可变的，所以它是可以被 * 共享的(即 不存在线程安全问题！) * 如下代码所示 * &lt;blockquote&gt;&lt;pre&gt; * String str = "abc"; * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt; * is equivalent to: * &lt;blockquote&gt;&lt;pre&gt; * char data[] = &#123;'a', 'b', 'c'&#125;; * String str = new String(data); * &lt;/pre&gt;&lt;/blockquote&gt;&lt;p&gt; * String的方法包含有 检查序列中的单个字符，比较字符串，查找串,提取子串，将其全部转换为大(小)写(这样会产生一个新的String对象)。大小写映射基于Unicode标准版本(该标准由java.lang.Character Character 类定义)。Java语言为 (字符)串及其衍生版本的字符串 的连接提供了特殊 的支持(即 操作符 +)。 String类的连接也通过 StringBuilder 和 StringBuffer 及其 append()方法实现。 * 字符串的转换 通过方法toString()实现， 该方法由Object类实现并且被Java中的所有类继承。 * 除非有特别说说明，否则传一个 null 给方法中的构造函数或者方法 都会产生一个 *NullPointerException 异常。 *String类型的字符串 默认以 UTF-16的格式显示 * @see java.lang.Object#toString() * @see java.lang.StringBuffer * @see java.lang.StringBuilder * @see java.nio.charset.Charset * @since JDK1.0 */public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** 该值用于存储 字符值。 注意 final修饰符，这也是其 不可变性的 原因 */ /**当在面试中 问到数据为什么不会被改变，不可变的原因时，首先就应该想到final修饰符*/ private final char value[]; /** 存储 串 的hash值，缺省为0 */ private int hash; /** 自jdk1.0.2起使用 serialVersionUID 为了提高互用性*/ private static final long serialVersionUID = -6849794470754667710L; /** * 字符串 类 在序列化流协议中比较特殊。 * 一个字符串对象实例 被写入到一个 ObjectOutputStream 中。 * ObjectStreamField: 可序列化类中可序列化字段的描述。ObjectStreamFields数组用于 * 声明类的可序列化字段。 */ private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; public String() &#123; this.value = "".value; &#125; /** * 除非是需要 original 的一个副本。否则使用该构造函数是无必要的，因为String是不可 * 变的。 */ public String(String original) &#123; this.value = original.value; this.hash = original.hash; &#125; /** * 字符数组的内容被复制到 一个String对象中，字符数组的值的改变不会影响 该字符串对象 */ public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length); &#125; /** * */ public String(char value[], int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= value.length) &#123; this.value = "".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; value.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; /** * 这个值传的优点绕， 调用的是native方法(即 C/C++写的) */ this.value = Arrays.copyOfRange(value, offset, offset+count); &#125; /** * 将Unicode编码数组 转换为 字符串 * @param codePoints UNicode编码值数组 * @since 1.5 */ public String(int[] codePoints, int offset, int count) &#123; if (offset &lt; 0) &#123; throw new StringIndexOutOfBoundsException(offset); &#125; if (count &lt;= 0) &#123; if (count &lt; 0) &#123; throw new StringIndexOutOfBoundsException(count); &#125; if (offset &lt;= codePoints.length) &#123; this.value = "".value; return; &#125; &#125; // Note: offset or count might be near -1&gt;&gt;&gt;1. if (offset &gt; codePoints.length - count) &#123; throw new StringIndexOutOfBoundsException(offset + count); &#125; final int end = offset + count; // Pass 1: Compute precise size of char[] int n = count; for (int i = offset; i &lt; end; i++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) continue; else if (Character.isValidCodePoint(c)) n++; else throw new IllegalArgumentException(Integer.toString(c)); &#125; // Pass 2: Allocate and fill in char[] final char[] v = new char[n]; for (int i = offset, j = 0; i &lt; end; i++, j++) &#123; int c = codePoints[i]; if (Character.isBmpCodePoint(c)) v[j] = (char)c; else Character.toSurrogates(c, v, j++); &#125; this.value = v; &#125; /** * 该方法并不常用。想要达成同样的效果，更好的方法是 使用带上 字符集名字 的构造函数 * 或者利用平台默认的字符集 * @param ascii 要转换为字符串的字节数组 * * @param hibyte 每个16位Unicode代码单元的前8位 * @see #String(byte[], int) * @see #String(byte[], int, int, java.lang.String) * @see #String(byte[], int, int, java.nio.charset.Charset) * @see #String(byte[], int, int) * @see #String(byte[], java.lang.String) * @see #String(byte[], java.nio.charset.Charset) * @see #String(byte[]) */ @Deprecated //过时的方法 public String(byte ascii[], int hibyte, int offset, int count) &#123; checkBounds(ascii, offset, count); char value[] = new char[count]; if (hibyte == 0) &#123; for (int i = count; i-- &gt; 0;) &#123; value[i] = (char)(ascii[i + offset] &amp; 0xff); &#125; &#125; else &#123; hibyte &lt;&lt;= 8; for (int i = count; i-- &gt; 0;) &#123; value[i] = (char)(hibyte | (ascii[i + offset] &amp; 0xff)); &#125; &#125; this.value = value; &#125; /** * @param ascii 想要转换为字符的字节 * * @param hibyte 每个16位Unicode代码单元的前8位 * @see #String(byte[], int, int, java.lang.String) * @see #String(byte[], int, int, java.nio.charset.Charset) * @see #String(byte[], int, int) * @see #String(byte[], java.lang.String) * @see #String(byte[], java.nio.charset.Charset) * @see #String(byte[]) */ @Deprecated // 过时的方法 public String(byte ascii[], int hibyte) &#123; this(ascii, hibyte, 0, ascii.length); &#125; /* * 边界检查， 检查传来的 offset length值是否符合要求 */ private static void checkBounds(byte[] bytes, int offset, int length) &#123; if (length &lt; 0) throw new StringIndexOutOfBoundsException(length); if (offset &lt; 0) throw new StringIndexOutOfBoundsException(offset); if (offset &gt; bytes.length - length) throw new StringIndexOutOfBoundsException(offset + length); &#125; /** * @param bytes 想要转换为字符串的字节数组 * The bytes to be decoded into characters * * @param offset * The index of the first byte to decode * * @param length * The number of bytes to decode * @param charsetName Charset类支持的 字符集编码 * The name of a supported &#123;@linkplain java.nio.charset.Charset * charset */ public String(byte bytes[], int offset, int length, String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException("charsetName"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charsetName, bytes, offset, length); &#125; /** */ public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException("charset"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length); &#125; /** */ public String(byte bytes[], String charsetName) throws UnsupportedEncodingException &#123; this(bytes, 0, bytes.length, charsetName); &#125; /** */ public String(byte bytes[], Charset charset) &#123; this(bytes, 0, bytes.length, charset); &#125; /** */ public String(byte bytes[], int offset, int length) &#123; checkBounds(bytes, offset, length); this.value = StringCoding.decode(bytes, offset, length); &#125; /** */ public String(byte bytes[]) &#123; this(bytes, 0, bytes.length); &#125; public String(StringBuffer buffer) &#123; synchronized(buffer) &#123; this.value = Arrays.copyOf(buffer.getValue(), buffer.length()); &#125; &#125; /** */ public String(StringBuilder builder) &#123; this.value = Arrays.copyOf(builder.getValue(), builder.length()); &#125; /** * shared 只能是 true */ String(char[] value, boolean share) &#123; // assert share : "unshared not supported"; this.value = value; &#125; /** * 返回字符串的长度，实际是 字符数组的长度。 * 差点看错，记住是 字符数组 不是字节！ */ public int length() &#123; return value.length; &#125; /** * 是否为空。 字符数组长度为0则为空 */ public boolean isEmpty() &#123; return value.length == 0; &#125; /** * 返回index处 的字符(从0开始，毕竟数组位置就是从0开始计数的) */ public char charAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return value[index]; &#125; /** * 返回index处的 编码点并将其转换为int整数返回，index 从 0 —— length-1 */ public int codePointAt(int index) &#123; if ((index &lt; 0) || (index &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointAtImpl(value, index, value.length); &#125; /** * Returns the character (Unicode code point) before the specified * index. The index refers to &#123;@code char&#125; values * (Unicode code units) and ranges from &#123;@code 1&#125; to &#123;@link * CharSequence#length() length&#125;. * * &lt;p&gt; If the &#123;@code char&#125; value at &#123;@code (index - 1)&#125; * is in the low-surrogate range, &#123;@code (index - 2)&#125; is not * negative, and the &#123;@code char&#125; value at &#123;@code (index - * 2)&#125; is in the high-surrogate range, then the * supplementary code point value of the surrogate pair is * returned. If the &#123;@code char&#125; value at &#123;@code index - * 1&#125; is an unpaired low-surrogate or a high-surrogate, the * surrogate value is returned. * * @param index the index following the code point that should be returned * @return the Unicode code point value before the given index. * @exception IndexOutOfBoundsException if the &#123;@code index&#125; * argument is less than 1 or greater than the length * of this string. * @since 1.5 */ public int codePointBefore(int index) &#123; int i = index - 1; if ((i &lt; 0) || (i &gt;= value.length)) &#123; throw new StringIndexOutOfBoundsException(index); &#125; return Character.codePointBeforeImpl(value, index, 0); &#125; /** * Returns the number of Unicode code points in the specified text * range of this &#123;@code String&#125;. The text range begins at the * specified &#123;@code beginIndex&#125; and extends to the * &#123;@code char&#125; at index &#123;@code endIndex - 1&#125;. Thus the * length (in &#123;@code char&#125;s) of the text range is * &#123;@code endIndex-beginIndex&#125;. Unpaired surrogates within * the text range count as one code point each. * * @param beginIndex the index to the first &#123;@code char&#125; of * the text range. * @param endIndex the index after the last &#123;@code char&#125; of * the text range. * @return the number of Unicode code points in the specified text * range * @exception IndexOutOfBoundsException if the * &#123;@code beginIndex&#125; is negative, or &#123;@code endIndex&#125; * is larger than the length of this &#123;@code String&#125;, or * &#123;@code beginIndex&#125; is larger than &#123;@code endIndex&#125;. * @since 1.5 */ public int codePointCount(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0 || endIndex &gt; value.length || beginIndex &gt; endIndex) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.codePointCountImpl(value, beginIndex, endIndex - beginIndex); &#125; /** * Returns the index within this &#123;@code String&#125; that is * offset from the given &#123;@code index&#125; by * &#123;@code codePointOffset&#125; code points. Unpaired surrogates * within the text range given by &#123;@code index&#125; and * &#123;@code codePointOffset&#125; count as one code point each. * * @param index the index to be offset * @param codePointOffset the offset in code points * @return the index within this &#123;@code String&#125; * @exception IndexOutOfBoundsException if &#123;@code index&#125; * is negative or larger then the length of this * &#123;@code String&#125;, or if &#123;@code codePointOffset&#125; is positive * and the substring starting with &#123;@code index&#125; has fewer * than &#123;@code codePointOffset&#125; code points, * or if &#123;@code codePointOffset&#125; is negative and the substring * before &#123;@code index&#125; has fewer than the absolute value * of &#123;@code codePointOffset&#125; code points. * @since 1.5 */ public int offsetByCodePoints(int index, int codePointOffset) &#123; if (index &lt; 0 || index &gt; value.length) &#123; throw new IndexOutOfBoundsException(); &#125; return Character.offsetByCodePointsImpl(value, 0, value.length, index, codePointOffset); &#125; /** * Copy characters from this string into dst starting at dstBegin. * This method doesn't perform any range checking. */ void getChars(char dst[], int dstBegin) &#123; System.arraycopy(value, 0, dst, dstBegin, value.length); &#125; /** * Copies characters from this string into the destination character * array. * &lt;p&gt; * The first character to be copied is at index &#123;@code srcBegin&#125;; * the last character to be copied is at index &#123;@code srcEnd-1&#125; * (thus the total number of characters to be copied is * &#123;@code srcEnd-srcBegin&#125;). The characters are copied into the * subarray of &#123;@code dst&#125; starting at index &#123;@code dstBegin&#125; * and ending at index: * &lt;blockquote&gt;&lt;pre&gt; * dstBegin + (srcEnd-srcBegin) - 1 * &lt;/pre&gt;&lt;/blockquote&gt; * * @param srcBegin index of the first character in the string * to copy. * @param srcEnd index after the last character in the string * to copy. * @param dst the destination array. * @param dstBegin the start offset in the destination array. * @exception IndexOutOfBoundsException If any of the following * is true: * &lt;ul&gt;&lt;li&gt;&#123;@code srcBegin&#125; is negative. * &lt;li&gt;&#123;@code srcBegin&#125; is greater than &#123;@code srcEnd&#125; * &lt;li&gt;&#123;@code srcEnd&#125; is greater than the length of this * string * &lt;li&gt;&#123;@code dstBegin&#125; is negative * &lt;li&gt;&#123;@code dstBegin+(srcEnd-srcBegin)&#125; is larger than * &#123;@code dst.length&#125;&lt;/ul&gt; */ public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin); &#125; /** * Copies characters from this string into the destination byte array. Each * byte receives the 8 low-order bits of the corresponding character. The * eight high-order bits of each character are not copied and do not * participate in the transfer in any way. * * &lt;p&gt; The first character to be copied is at index &#123;@code srcBegin&#125;; the * last character to be copied is at index &#123;@code srcEnd-1&#125;. The total * number of characters to be copied is &#123;@code srcEnd-srcBegin&#125;. The * characters, converted to bytes, are copied into the subarray of &#123;@code * dst&#125; starting at index &#123;@code dstBegin&#125; and ending at index: * * &lt;blockquote&gt;&lt;pre&gt; * dstBegin + (srcEnd-srcBegin) - 1 * &lt;/pre&gt;&lt;/blockquote&gt; * * @deprecated This method does not properly convert characters into * bytes. As of JDK&amp;nbsp;1.1, the preferred way to do this is via the * &#123;@link #getBytes()&#125; method, which uses the platform's default charset. * * @param srcBegin * Index of the first character in the string to copy * * @param srcEnd * Index after the last character in the string to copy * * @param dst * The destination array * * @param dstBegin * The start offset in the destination array * * @throws IndexOutOfBoundsException * If any of the following is true: * &lt;ul&gt; * &lt;li&gt; &#123;@code srcBegin&#125; is negative * &lt;li&gt; &#123;@code srcBegin&#125; is greater than &#123;@code srcEnd&#125; * &lt;li&gt; &#123;@code srcEnd&#125; is greater than the length of this String * &lt;li&gt; &#123;@code dstBegin&#125; is negative * &lt;li&gt; &#123;@code dstBegin+(srcEnd-srcBegin)&#125; is larger than &#123;@code * dst.length&#125; * &lt;/ul&gt; */ @Deprecated public void getBytes(int srcBegin, int srcEnd, byte dst[], int dstBegin) &#123; if (srcBegin &lt; 0) &#123; throw new StringIndexOutOfBoundsException(srcBegin); &#125; if (srcEnd &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(srcEnd); &#125; if (srcBegin &gt; srcEnd) &#123; throw new StringIndexOutOfBoundsException(srcEnd - srcBegin); &#125; Objects.requireNonNull(dst); int j = dstBegin; int n = srcEnd; int i = srcBegin; char[] val = value; /* avoid getfield opcode */ while (i &lt; n) &#123; dst[j++] = (byte)val[i++]; &#125; &#125; /** * Encodes this &#123;@code String&#125; into a sequence of bytes using the named * charset, storing the result into a new byte array. * * &lt;p&gt; The behavior of this method when this string cannot be encoded in * the given charset is unspecified. The &#123;@link * java.nio.charset.CharsetEncoder&#125; class should be used when more control * over the encoding process is required. * * @param charsetName * The name of a supported &#123;@linkplain java.nio.charset.Charset * charset&#125; * * @return The resultant byte array * * @throws UnsupportedEncodingException * If the named charset is not supported * * @since JDK1.1 */ public byte[] getBytes(String charsetName) throws UnsupportedEncodingException &#123; if (charsetName == null) throw new NullPointerException(); return StringCoding.encode(charsetName, value, 0, value.length); &#125; /** * Encodes this &#123;@code String&#125; into a sequence of bytes using the given * &#123;@linkplain java.nio.charset.Charset charset&#125;, storing the result into a * new byte array. * * &lt;p&gt; This method always replaces malformed-input and unmappable-character * sequences with this charset's default replacement byte array. The * &#123;@link java.nio.charset.CharsetEncoder&#125; class should be used when more * control over the encoding process is required. * * @param charset * The &#123;@linkplain java.nio.charset.Charset&#125; to be used to encode * the &#123;@code String&#125; * * @return The resultant byte array * * @since 1.6 */ public byte[] getBytes(Charset charset) &#123; if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length); &#125; /** * Encodes this &#123;@code String&#125; into a sequence of bytes using the * platform's default charset, storing the result into a new byte array. * * &lt;p&gt; The behavior of this method when this string cannot be encoded in * the default charset is unspecified. The &#123;@link * java.nio.charset.CharsetEncoder&#125; class should be used when more control * over the encoding process is required. * * @return The resultant byte array * * @since JDK1.1 */ public byte[] getBytes() &#123; return StringCoding.encode(value, 0, value.length); &#125; /** * Compares this string to the specified object. The result is &#123;@code * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code * String&#125; object that represents the same sequence of characters as this * object. * * @param anObject * The object to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the given object represents a &#123;@code String&#125; * equivalent to this string, &#123;@code false&#125; otherwise * * @see #compareTo(String) * @see #equalsIgnoreCase(String) */ public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; /** * Compares this string to the specified &#123;@code StringBuffer&#125;. The result * is &#123;@code true&#125; if and only if this &#123;@code String&#125; represents the same * sequence of characters as the specified &#123;@code StringBuffer&#125;. This method * synchronizes on the &#123;@code StringBuffer&#125;. * * @param sb * The &#123;@code StringBuffer&#125; to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if this &#123;@code String&#125; represents the same * sequence of characters as the specified &#123;@code StringBuffer&#125;, * &#123;@code false&#125; otherwise * * @since 1.4 */ public boolean contentEquals(StringBuffer sb) &#123; return contentEquals((CharSequence)sb); &#125; private boolean nonSyncContentEquals(AbstractStringBuilder sb) &#123; char v1[] = value; char v2[] = sb.getValue(); int n = v1.length; if (n != sb.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != v2[i]) &#123; return false; &#125; &#125; return true; &#125; /** * Compares this string to the specified &#123;@code CharSequence&#125;. The * result is &#123;@code true&#125; if and only if this &#123;@code String&#125; represents the * same sequence of char values as the specified sequence. Note that if the * &#123;@code CharSequence&#125; is a &#123;@code StringBuffer&#125; then the method * synchronizes on it. * * @param cs * The sequence to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if this &#123;@code String&#125; represents the same * sequence of char values as the specified sequence, &#123;@code * false&#125; otherwise * * @since 1.5 */ public boolean contentEquals(CharSequence cs) &#123; // Argument is a StringBuffer, StringBuilder if (cs instanceof AbstractStringBuilder) &#123; if (cs instanceof StringBuffer) &#123; synchronized(cs) &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; else &#123; return nonSyncContentEquals((AbstractStringBuilder)cs); &#125; &#125; // Argument is a String if (cs instanceof String) &#123; return equals(cs); &#125; // Argument is a generic CharSequence char v1[] = value; int n = v1.length; if (n != cs.length()) &#123; return false; &#125; for (int i = 0; i &lt; n; i++) &#123; if (v1[i] != cs.charAt(i)) &#123; return false; &#125; &#125; return true; &#125; /** * Compares this &#123;@code String&#125; to another &#123;@code String&#125;, ignoring case * considerations. Two strings are considered equal ignoring case if they * are of the same length and corresponding characters in the two strings * are equal ignoring case. * * &lt;p&gt; Two characters &#123;@code c1&#125; and &#123;@code c2&#125; are considered the same * ignoring case if at least one of the following is true: * &lt;ul&gt; * &lt;li&gt; The two characters are the same (as compared by the * &#123;@code ==&#125; operator) * &lt;li&gt; Applying the method &#123;@link * java.lang.Character#toUpperCase(char)&#125; to each character * produces the same result * &lt;li&gt; Applying the method &#123;@link * java.lang.Character#toLowerCase(char)&#125; to each character * produces the same result * &lt;/ul&gt; * * @param anotherString * The &#123;@code String&#125; to compare this &#123;@code String&#125; against * * @return &#123;@code true&#125; if the argument is not &#123;@code null&#125; and it * represents an equivalent &#123;@code String&#125; ignoring case; &#123;@code * false&#125; otherwise * * @see #equals(Object) */ public boolean equalsIgnoreCase(String anotherString) &#123; return (this == anotherString) ? true : (anotherString != null) &amp;&amp; (anotherString.value.length == value.length) &amp;&amp; regionMatches(true, 0, anotherString, 0, value.length); &#125; /** * Compares two strings lexicographically. * The comparison is based on the Unicode value of each character in * the strings. The character sequence represented by this * &#123;@code String&#125; object is compared lexicographically to the * character sequence represented by the argument string. The result is * a negative integer if this &#123;@code String&#125; object * lexicographically precedes the argument string. The result is a * positive integer if this &#123;@code String&#125; object lexicographically * follows the argument string. The result is zero if the strings * are equal; &#123;@code compareTo&#125; returns &#123;@code 0&#125; exactly when * the &#123;@link #equals(Object)&#125; method would return &#123;@code true&#125;. * &lt;p&gt; * This is the definition of lexicographic ordering. If two strings are * different, then either they have different characters at some index * that is a valid index for both strings, or their lengths are different, * or both. If they have different characters at one or more index * positions, let &lt;i&gt;k&lt;/i&gt; be the smallest such index; then the string * whose character at position &lt;i&gt;k&lt;/i&gt; has the smaller value, as * determined by using the &amp;lt; operator, lexicographically precedes the * other string. In this case, &#123;@code compareTo&#125; returns the * difference of the two character values at position &#123;@code k&#125; in * the two string -- that is, the value: * &lt;blockquote&gt;&lt;pre&gt; * this.charAt(k)-anotherString.charAt(k) * &lt;/pre&gt;&lt;/blockquote&gt; * If there is no index position at which they differ, then the shorter * string lexicographically precedes the longer string. In this case, * &#123;@code compareTo&#125; returns the difference of the lengths of the * strings -- that is, the value: * &lt;blockquote&gt;&lt;pre&gt; * this.length()-anotherString.length() * &lt;/pre&gt;&lt;/blockquote&gt; * * @param anotherString the &#123;@code String&#125; to be compared. * @return the value &#123;@code 0&#125; if the argument string is equal to * this string; a value less than &#123;@code 0&#125; if this string * is lexicographically less than the string argument; and a * value greater than &#123;@code 0&#125; if this string is * lexicographically greater than the string argument. */ public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; return c1 - c2; &#125; k++; &#125; return len1 - len2; &#125; /** * A Comparator that orders &#123;@code String&#125; objects as by * &#123;@code compareToIgnoreCase&#125;. This comparator is serializable. * &lt;p&gt; * Note that this Comparator does &lt;em&gt;not&lt;/em&gt; take locale into account, * and will result in an unsatisfactory ordering for certain locales. * The java.text package provides &lt;em&gt;Collators&lt;/em&gt; to allow * locale-sensitive ordering. * * @see java.text.Collator#compare(String, String) * @since 1.2 */ public static final Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = new CaseInsensitiveComparator(); private static class CaseInsensitiveComparator implements Comparator&lt;String&gt;, java.io.Serializable &#123; // use serialVersionUID from JDK 1.2.2 for interoperability private static final long serialVersionUID = 8575799808933029326L; public int compare(String s1, String s2) &#123; int n1 = s1.length(); int n2 = s2.length(); int min = Math.min(n1, n2); for (int i = 0; i &lt; min; i++) &#123; char c1 = s1.charAt(i); char c2 = s2.charAt(i); if (c1 != c2) &#123; c1 = Character.toUpperCase(c1); c2 = Character.toUpperCase(c2); if (c1 != c2) &#123; c1 = Character.toLowerCase(c1); c2 = Character.toLowerCase(c2); if (c1 != c2) &#123; // No overflow because of numeric promotion return c1 - c2; &#125; &#125; &#125; &#125; return n1 - n2; &#125; /** Replaces the de-serialized object. */ private Object readResolve() &#123; return CASE_INSENSITIVE_ORDER; &#125; &#125; /** * Compares two strings lexicographically, ignoring case * differences. This method returns an integer whose sign is that of * calling &#123;@code compareTo&#125; with normalized versions of the strings * where case differences have been eliminated by calling * &#123;@code Character.toLowerCase(Character.toUpperCase(character))&#125; on * each character. * &lt;p&gt; * Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account, * and will result in an unsatisfactory ordering for certain locales. * The java.text package provides &lt;em&gt;collators&lt;/em&gt; to allow * locale-sensitive ordering. * * @param str the &#123;@code String&#125; to be compared. * @return a negative integer, zero, or a positive integer as the * specified String is greater than, equal to, or less * than this String, ignoring case considerations. * @see java.text.Collator#compare(String, String) * @since 1.2 */ public int compareToIgnoreCase(String str) &#123; return CASE_INSENSITIVE_ORDER.compare(this, str); &#125; /** * Tests if two string regions are equal. * &lt;p&gt; * A substring of this &#123;@code String&#125; object is compared to a substring * of the argument other. The result is true if these substrings * represent identical character sequences. The substring of this * &#123;@code String&#125; object to be compared begins at index &#123;@code toffset&#125; * and has length &#123;@code len&#125;. The substring of other to be compared * begins at index &#123;@code ooffset&#125; and has length &#123;@code len&#125;. The * result is &#123;@code false&#125; if and only if at least one of the following * is true: * &lt;ul&gt;&lt;li&gt;&#123;@code toffset&#125; is negative. * &lt;li&gt;&#123;@code ooffset&#125; is negative. * &lt;li&gt;&#123;@code toffset+len&#125; is greater than the length of this * &#123;@code String&#125; object. * &lt;li&gt;&#123;@code ooffset+len&#125; is greater than the length of the other * argument. * &lt;li&gt;There is some nonnegative integer &lt;i&gt;k&lt;/i&gt; less than &#123;@code len&#125; * such that: * &#123;@code this.charAt(toffset + &#125;&lt;i&gt;k&lt;/i&gt;&#123;@code ) != other.charAt(ooffset + &#125; * &lt;i&gt;k&lt;/i&gt;&#123;@code )&#125; * &lt;/ul&gt; * * @param toffset the starting offset of the subregion in this string. * @param other the string argument. * @param ooffset the starting offset of the subregion in the string * argument. * @param len the number of characters to compare. * @return &#123;@code true&#125; if the specified subregion of this string * exactly matches the specified subregion of the string argument; * &#123;@code false&#125; otherwise. */ public boolean regionMatches(int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; /** * Tests if two string regions are equal. * &lt;p&gt; * A substring of this &#123;@code String&#125; object is compared to a substring * of the argument &#123;@code other&#125;. The result is &#123;@code true&#125; if these * substrings represent character sequences that are the same, ignoring * case if and only if &#123;@code ignoreCase&#125; is true. The substring of * this &#123;@code String&#125; object to be compared begins at index * &#123;@code toffset&#125; and has length &#123;@code len&#125;. The substring of * &#123;@code other&#125; to be compared begins at index &#123;@code ooffset&#125; and * has length &#123;@code len&#125;. The result is &#123;@code false&#125; if and only if * at least one of the following is true: * &lt;ul&gt;&lt;li&gt;&#123;@code toffset&#125; is negative. * &lt;li&gt;&#123;@code ooffset&#125; is negative. * &lt;li&gt;&#123;@code toffset+len&#125; is greater than the length of this * &#123;@code String&#125; object. * &lt;li&gt;&#123;@code ooffset+len&#125; is greater than the length of the other * argument. * &lt;li&gt;&#123;@code ignoreCase&#125; is &#123;@code false&#125; and there is some nonnegative * integer &lt;i&gt;k&lt;/i&gt; less than &#123;@code len&#125; such that: * &lt;blockquote&gt;&lt;pre&gt; * this.charAt(toffset+k) != other.charAt(ooffset+k) * &lt;/pre&gt;&lt;/blockquote&gt; * &lt;li&gt;&#123;@code ignoreCase&#125; is &#123;@code true&#125; and there is some nonnegative * integer &lt;i&gt;k&lt;/i&gt; less than &#123;@code len&#125; such that: * &lt;blockquote&gt;&lt;pre&gt; * Character.toLowerCase(this.charAt(toffset+k)) != Character.toLowerCase(other.charAt(ooffset+k)) * &lt;/pre&gt;&lt;/blockquote&gt; * and: * &lt;blockquote&gt;&lt;pre&gt; * Character.toUpperCase(this.charAt(toffset+k)) != * Character.toUpperCase(other.charAt(ooffset+k)) * &lt;/pre&gt;&lt;/blockquote&gt; * &lt;/ul&gt; * * @param ignoreCase if &#123;@code true&#125;, ignore case when comparing * characters. * @param toffset the starting offset of the subregion in this * string. * @param other the string argument. * @param ooffset the starting offset of the subregion in the string * argument. * @param len the number of characters to compare. * @return &#123;@code true&#125; if the specified subregion of this string * matches the specified subregion of the string argument; * &#123;@code false&#125; otherwise. Whether the matching is exact * or case insensitive depends on the &#123;@code ignoreCase&#125; * argument. */ public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; // Note: toffset, ooffset, or len might be near -1&gt;&gt;&gt;1. if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // If characters don't match but case may be ignored, // try converting both characters to uppercase. // If the results match, then the comparison scan should // continue. char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; // Unfortunately, conversion to uppercase does not work properly // for the Georgian alphabet, which has strange rules about case // conversion. So we need to make one last check before // exiting. if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true; &#125; /** * Tests if the substring of this string beginning at the * specified index starts with the specified prefix. * * @param prefix the prefix. * @param toffset where to begin looking in this string. * @return &#123;@code true&#125; if the character sequence represented by the * argument is a prefix of the substring of this object starting * at index &#123;@code toffset&#125;; &#123;@code false&#125; otherwise. * The result is &#123;@code false&#125; if &#123;@code toffset&#125; is * negative or greater than the length of this * &#123;@code String&#125; object; otherwise the result is the same * as the result of the expression * &lt;pre&gt; * this.substring(toffset).startsWith(prefix) * &lt;/pre&gt; */ public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; // Note: toffset might be near -1&gt;&gt;&gt;1. if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true; &#125; /** * Tests if this string starts with the specified prefix. * * @param prefix the prefix. * @return &#123;@code true&#125; if the character sequence represented by the * argument is a prefix of the character sequence represented by * this string; &#123;@code false&#125; otherwise. * Note also that &#123;@code true&#125; will be returned if the * argument is an empty string or is equal to this * &#123;@code String&#125; object as determined by the * &#123;@link #equals(Object)&#125; method. * @since 1. 0 */ public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0); &#125; /** * Tests if this string ends with the specified suffix. * * @param suffix the suffix. * @return &#123;@code true&#125; if the character sequence represented by the * argument is a suffix of the character sequence represented by * this object; &#123;@code false&#125; otherwise. Note that the * result will be &#123;@code true&#125; if the argument is the * empty string or is equal to this &#123;@code String&#125; object * as determined by the &#123;@link #equals(Object)&#125; method. */ public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length); &#125; /** * Returns a hash code for this string. The hash code for a * &#123;@code String&#125; object is computed as * &lt;blockquote&gt;&lt;pre&gt; * s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] * &lt;/pre&gt;&lt;/blockquote&gt; * using &#123;@code int&#125; arithmetic, where &#123;@code s[i]&#125; is the * &lt;i&gt;i&lt;/i&gt;th character of the string, &#123;@code n&#125; is the length of * the string, and &#123;@code ^&#125; indicates exponentiation. * (The hash value of the empty string is zero.) * * @return a hash code value for this object. */ public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h; &#125; /** * Returns the index within this string of the first occurrence of * the specified character. If a character with value * &#123;@code ch&#125; occurs in the character sequence represented by * this &#123;@code String&#125; object, then the index (in Unicode * code units) of the first such occurrence is returned. For * values of &#123;@code ch&#125; in the range from 0 to 0xFFFF * (inclusive), this is the smallest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch * &lt;/pre&gt;&lt;/blockquote&gt; * is true. For other values of &#123;@code ch&#125;, it is the * smallest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch * &lt;/pre&gt;&lt;/blockquote&gt; * is true. In either case, if no such character occurs in this * string, then &#123;@code -1&#125; is returned. * * @param ch a character (Unicode code point). * @return the index of the first occurrence of the character in the * character sequence represented by this object, or * &#123;@code -1&#125; if the character does not occur. */ public int indexOf(int ch) &#123; return indexOf(ch, 0); &#125; /** * Returns the index within this string of the first occurrence of the * specified character, starting the search at the specified index. * &lt;p&gt; * If a character with value &#123;@code ch&#125; occurs in the * character sequence represented by this &#123;@code String&#125; * object at an index no smaller than &#123;@code fromIndex&#125;, then * the index of the first such occurrence is returned. For values * of &#123;@code ch&#125; in the range from 0 to 0xFFFF (inclusive), * this is the smallest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * (this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch) &#123;@code &amp;&amp;&#125; (&lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex) * &lt;/pre&gt;&lt;/blockquote&gt; * is true. For other values of &#123;@code ch&#125;, it is the * smallest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * (this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch) &#123;@code &amp;&amp;&#125; (&lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex) * &lt;/pre&gt;&lt;/blockquote&gt; * is true. In either case, if no such character occurs in this * string at or after position &#123;@code fromIndex&#125;, then * &#123;@code -1&#125; is returned. * * &lt;p&gt; * There is no restriction on the value of &#123;@code fromIndex&#125;. If it * is negative, it has the same effect as if it were zero: this entire * string may be searched. If it is greater than the length of this * string, it has the same effect as if it were equal to the length of * this string: &#123;@code -1&#125; is returned. * * &lt;p&gt;All indices are specified in &#123;@code char&#125; values * (Unicode code units). * * @param ch a character (Unicode code point). * @param fromIndex the index to start the search from. * @return the index of the first occurrence of the character in the * character sequence represented by this object that is greater * than or equal to &#123;@code fromIndex&#125;, or &#123;@code -1&#125; * if the character does not occur. */ public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; // Note: fromIndex might be near -1&gt;&gt;&gt;1. return -1; &#125; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125; &#125; /** * Handles (rare) calls of indexOf with a supplementary character. */ private int indexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; final char hi = Character.highSurrogate(ch); final char lo = Character.lowSurrogate(ch); final int max = value.length - 1; for (int i = fromIndex; i &lt; max; i++) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * Returns the index within this string of the last occurrence of * the specified character. For values of &#123;@code ch&#125; in the * range from 0 to 0xFFFF (inclusive), the index (in Unicode code * units) returned is the largest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch * &lt;/pre&gt;&lt;/blockquote&gt; * is true. For other values of &#123;@code ch&#125;, it is the * largest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch * &lt;/pre&gt;&lt;/blockquote&gt; * is true. In either case, if no such character occurs in this * string, then &#123;@code -1&#125; is returned. The * &#123;@code String&#125; is searched backwards starting at the last * character. * * @param ch a character (Unicode code point). * @return the index of the last occurrence of the character in the * character sequence represented by this object, or * &#123;@code -1&#125; if the character does not occur. */ public int lastIndexOf(int ch) &#123; return lastIndexOf(ch, value.length - 1); &#125; /** * Returns the index within this string of the last occurrence of * the specified character, searching backward starting at the * specified index. For values of &#123;@code ch&#125; in the range * from 0 to 0xFFFF (inclusive), the index returned is the largest * value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * (this.charAt(&lt;i&gt;k&lt;/i&gt;) == ch) &#123;@code &amp;&amp;&#125; (&lt;i&gt;k&lt;/i&gt; &amp;lt;= fromIndex) * &lt;/pre&gt;&lt;/blockquote&gt; * is true. For other values of &#123;@code ch&#125;, it is the * largest value &lt;i&gt;k&lt;/i&gt; such that: * &lt;blockquote&gt;&lt;pre&gt; * (this.codePointAt(&lt;i&gt;k&lt;/i&gt;) == ch) &#123;@code &amp;&amp;&#125; (&lt;i&gt;k&lt;/i&gt; &amp;lt;= fromIndex) * &lt;/pre&gt;&lt;/blockquote&gt; * is true. In either case, if no such character occurs in this * string at or before position &#123;@code fromIndex&#125;, then * &#123;@code -1&#125; is returned. * * &lt;p&gt;All indices are specified in &#123;@code char&#125; values * (Unicode code units). * * @param ch a character (Unicode code point). * @param fromIndex the index to start the search from. There is no * restriction on the value of &#123;@code fromIndex&#125;. If it is * greater than or equal to the length of this string, it has * the same effect as if it were equal to one less than the * length of this string: this entire string may be searched. * If it is negative, it has the same effect as if it were -1: * -1 is returned. * @return the index of the last occurrence of the character in the * character sequence represented by this object that is less * than or equal to &#123;@code fromIndex&#125;, or &#123;@code -1&#125; * if the character does not occur before that point. */ public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125; &#125; /** * Handles (rare) calls of lastIndexOf with a supplementary character. */ private int lastIndexOfSupplementary(int ch, int fromIndex) &#123; if (Character.isValidCodePoint(ch)) &#123; final char[] value = this.value; char hi = Character.highSurrogate(ch); char lo = Character.lowSurrogate(ch); int i = Math.min(fromIndex, value.length - 2); for (; i &gt;= 0; i--) &#123; if (value[i] == hi &amp;&amp; value[i + 1] == lo) &#123; return i; &#125; &#125; &#125; return -1; &#125; /** * Returns the index within this string of the first occurrence of the * specified substring. * * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @return the index of the first occurrence of the specified substring, * or &#123;@code -1&#125; if there is no such occurrence. */ public int indexOf(String str) &#123; return indexOf(str, 0); &#125; /** * Returns the index within this string of the first occurrence of the * specified substring, starting at the specified index. * * &lt;p&gt;The returned index is the smallest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * &lt;i&gt;k&lt;/i&gt; &amp;gt;= fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @param fromIndex the index from which to start the search. * @return the index of the first occurrence of the specified substring, * starting at the specified index, * or &#123;@code -1&#125; if there is no such occurrence. */ public int indexOf(String str, int fromIndex) &#123; return indexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; /** * Code shared by String and AbstractStringBuilder to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param fromIndex the index to begin searching from. */ static int indexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return indexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex); &#125; /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param targetOffset offset of the target string. * @param targetCount count of the target string. * @param fromIndex the index to begin searching from. */ static int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; if (fromIndex &gt;= sourceCount) &#123; return (targetCount == 0 ? sourceCount : -1); &#125; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; if (targetCount == 0) &#123; return fromIndex; &#125; char first = target[targetOffset]; int max = sourceOffset + (sourceCount - targetCount); for (int i = sourceOffset + fromIndex; i &lt;= max; i++) &#123; /* Look for first character. */ if (source[i] != first) &#123; while (++i &lt;= max &amp;&amp; source[i] != first); &#125; /* Found first character, now look at the rest of v2 */ if (i &lt;= max) &#123; int j = i + 1; int end = j + targetCount - 1; for (int k = targetOffset + 1; j &lt; end &amp;&amp; source[j] == target[k]; j++, k++); if (j == end) &#123; /* Found whole string. */ return i - sourceOffset; &#125; &#125; &#125; return -1; &#125; /** * Returns the index within this string of the last occurrence of the * specified substring. The last occurrence of the empty string "" * is considered to occur at the index value &#123;@code this.length()&#125;. * * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @return the index of the last occurrence of the specified substring, * or &#123;@code -1&#125; if there is no such occurrence. */ public int lastIndexOf(String str) &#123; return lastIndexOf(str, value.length); &#125; /** * Returns the index within this string of the last occurrence of the * specified substring, searching backward starting at the specified index. * * &lt;p&gt;The returned index is the largest value &lt;i&gt;k&lt;/i&gt; for which: * &lt;blockquote&gt;&lt;pre&gt; * &lt;i&gt;k&lt;/i&gt; &#123;@code &lt;=&#125; fromIndex &#123;@code &amp;&amp;&#125; this.startsWith(str, &lt;i&gt;k&lt;/i&gt;) * &lt;/pre&gt;&lt;/blockquote&gt; * If no such value of &lt;i&gt;k&lt;/i&gt; exists, then &#123;@code -1&#125; is returned. * * @param str the substring to search for. * @param fromIndex the index to start the search from. * @return the index of the last occurrence of the specified substring, * searching backward from the specified index, * or &#123;@code -1&#125; if there is no such occurrence. */ public int lastIndexOf(String str, int fromIndex) &#123; return lastIndexOf(value, 0, value.length, str.value, 0, str.value.length, fromIndex); &#125; /** * Code shared by String and AbstractStringBuilder to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param fromIndex the index to begin searching from. */ static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, String target, int fromIndex) &#123; return lastIndexOf(source, sourceOffset, sourceCount, target.value, 0, target.value.length, fromIndex); &#125; /** * Code shared by String and StringBuffer to do searches. The * source is the character array being searched, and the target * is the string being searched for. * * @param source the characters being searched. * @param sourceOffset offset of the source string. * @param sourceCount count of the source string. * @param target the characters being searched for. * @param targetOffset offset of the target string. * @param targetCount count of the target string. * @param fromIndex the index to begin searching from. */ static int lastIndexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) &#123; /* * Check arguments; return immediately where possible. For * consistency, don't check for null str. */ int rightIndex = sourceCount - targetCount; if (fromIndex &lt; 0) &#123; return -1; &#125; if (fromIndex &gt; rightIndex) &#123; fromIndex = rightIndex; &#125; /* Empty string always matches. */ if (targetCount == 0) &#123; return fromIndex; &#125; int strLastIndex = targetOffset + targetCount - 1; char strLastChar = target[strLastIndex]; int min = sourceOffset + targetCount - 1; int i = min + fromIndex; startSearchForLastChar: while (true) &#123; while (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123; i--; &#125; if (i &lt; min) &#123; return -1; &#125; int j = i - 1; int start = j - (targetCount - 1); int k = strLastIndex - 1; while (j &gt; start) &#123; if (source[j--] != target[k--]) &#123; i--; continue startSearchForLastChar; &#125; &#125; return start - sourceOffset + 1; &#125; &#125; /** */ public String substring(int beginIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; int subLen = value.length - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); &#125; /** */ public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); &#125; /** * 返回原串子序列 */ public CharSequence subSequence(int beginIndex, int endIndex) &#123; return this.substring(beginIndex, endIndex); &#125; /** * 将给定串 加在源串后 */ public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; char buf[] = Arrays.copyOf(value, len + otherLen); str.getChars(buf, len); return new String(buf, true); &#125; /** * 替换单个 字符 */ public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; /* avoid getfield opcode */ while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; while (i &lt; len) &#123; char c = val[i]; buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true); &#125; &#125; return this; &#125; /** * 字符串是否匹配 给定的正则表达式 */ public boolean matches(String regex) &#123; return Pattern.matches(regex, this); &#125; /** * */ public boolean contains(CharSequence s) &#123; return indexOf(s.toString()) &gt; -1; &#125; /** * 从前往后 替换第一个符合正则的 子串 */ public String replaceFirst(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceFirst(replacement); &#125; /** * 将符合正则表达式regex的子串全部替换 */ public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement); &#125; /** * Replaces each substring of this string that matches the literal target * sequence with the specified literal replacement sequence. The * replacement proceeds from the beginning of the string to the end, for * example, replacing "aa" with "b" in the string "aaa" will result in * "ba" rather than "ab". * * @param target The sequence of char values to be replaced * @param replacement The replacement sequence of char values * @return The resulting string * @since 1.5 */ public String replace(CharSequence target, CharSequence replacement) &#123; return Pattern.compile(target.toString(), Pattern.LITERAL).matcher( this).replaceAll(Matcher.quoteReplacement(replacement.toString())); &#125; /** * limit 限制结果数。 当分割的结果数已经到了n时，剩余的 子字符串将不再进行分割 而是直接返回 * @param regex * the delimiting regular expression * * @param limit * the result threshold, as described above * * @return the array of strings computed by splitting this string * around matches of the given regular expression * * @throws PatternSyntaxException * if the regular expression's syntax is invalid * * @see java.util.regex.Pattern * * @since 1.4 * @spec JSR-51 */ public String[] split(String regex, int limit) &#123; /* fastpath if the regex is a (1)one-char String and this character is not one of the RegEx's meta characters ".$|()[&#123;^?*+\\", or (2)two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. */ char ch = 0; if (((regex.value.length == 1 &amp;&amp; ".$|()[&#123;^?*+\\".indexOf(ch = regex.charAt(0)) == -1) || (regex.length() == 2 &amp;&amp; regex.charAt(0) == '\\' &amp;&amp; (((ch = regex.charAt(1))-'0')|('9'-ch)) &lt; 0 &amp;&amp; ((ch-'a')|('z'-ch)) &lt; 0 &amp;&amp; ((ch-'A')|('Z'-ch)) &lt; 0)) &amp;&amp; (ch &lt; Character.MIN_HIGH_SURROGATE || ch &gt; Character.MAX_LOW_SURROGATE)) &#123; int off = 0; int next = 0; boolean limited = limit &gt; 0; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); while ((next = indexOf(ch, off)) != -1) &#123; if (!limited || list.size() &lt; limit - 1) &#123; list.add(substring(off, next)); off = next + 1; &#125; else &#123; // last one //assert (list.size() == limit - 1); list.add(substring(off, value.length)); off = value.length; break; &#125; &#125; // If no match was found, return this if (off == 0) return new String[]&#123;this&#125;; // Add remaining segment if (!limited || list.size() &lt; limit) list.add(substring(off, value.length)); // Construct result int resultSize = list.size(); if (limit == 0) &#123; while (resultSize &gt; 0 &amp;&amp; list.get(resultSize - 1).length() == 0) &#123; resultSize--; &#125; &#125; String[] result = new String[resultSize]; return list.subList(0, resultSize).toArray(result); &#125; return Pattern.compile(regex).split(this, limit); &#125; /** *执行 分割符(也是一个字符串对象) 去分割字符串 * @param regex * the delimiting regular expression */ public String[] split(String regex) &#123; return split(regex, 0); &#125; /** * 将一个集合中的多个字符串连接起来-可用指定的分割符， 返回该连接后的String对象 * @see java.util.StringJoiner * @since 1.8 */ public static String join(CharSequence delimiter, CharSequence... elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); // Number of elements not likely worth Arrays.stream overhead. StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString(); &#125; /** * Returns a new &#123;@code String&#125; composed of copies of the * &#123;@code CharSequence elements&#125; joined together with a copy of the * specified &#123;@code delimiter&#125;. * * &lt;blockquote&gt;For example, * &lt;pre&gt;&#123;@code * List&lt;String&gt; strings = new LinkedList&lt;&gt;(); * strings.add("Java");strings.add("is"); * strings.add("cool"); * String message = String.join(" ", strings); * //message returned is: "Java is cool" * * Set&lt;String&gt; strings = new LinkedHashSet&lt;&gt;(); * strings.add("Java"); strings.add("is"); * strings.add("very"); strings.add("cool"); * String message = String.join("-", strings); * //message returned is: "Java-is-very-cool" * &#125;&lt;/pre&gt;&lt;/blockquote&gt; * * Note that if an individual element is &#123;@code null&#125;, then &#123;@code "null"&#125; is added. */ public static String join(CharSequence delimiter, Iterable&lt;? extends CharSequence&gt; elements) &#123; Objects.requireNonNull(delimiter); Objects.requireNonNull(elements); StringJoiner joiner = new StringJoiner(delimiter); for (CharSequence cs: elements) &#123; joiner.add(cs); &#125; return joiner.toString(); &#125; /** * Converts all of the characters in this &#123;@code String&#125; to lower * case using the rules of the given &#123;@code Locale&#125;. Case mapping is based * on the Unicode Standard version specified by the &#123;@link java.lang.Character Character&#125; * class. Since case mappings are not always 1:1 char mappings, the resulting * &#123;@code String&#125; may be a different length than the original &#123;@code String&#125;. * &lt;p&gt; * Examples of lowercase mappings are in the following table: * &lt;table border="1" summary="Lowercase mapping examples showing language code of locale, upper case, lower case, and description"&gt; * &lt;tr&gt; * &lt;th&gt;Language Code of Locale&lt;/th&gt; * &lt;th&gt;Upper Case&lt;/th&gt; * &lt;th&gt;Lower Case&lt;/th&gt; * &lt;th&gt;Description&lt;/th&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;tr (Turkish)&lt;/td&gt; * &lt;td&gt;&amp;#92;u0130&lt;/td&gt; * &lt;td&gt;&amp;#92;u0069&lt;/td&gt; * &lt;td&gt;capital letter I with dot above -&amp;gt; small letter i&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;tr (Turkish)&lt;/td&gt; * &lt;td&gt;&amp;#92;u0049&lt;/td&gt; * &lt;td&gt;&amp;#92;u0131&lt;/td&gt; * &lt;td&gt;capital letter I -&amp;gt; small letter dotless i &lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;(all)&lt;/td&gt; * &lt;td&gt;French Fries&lt;/td&gt; * &lt;td&gt;french fries&lt;/td&gt; * &lt;td&gt;lowercased all chars in String&lt;/td&gt; * &lt;/tr&gt; * &lt;tr&gt; * &lt;td&gt;(all)&lt;/td&gt; * &lt;td&gt;&lt;img src="doc-files/capiota.gif" alt="capiota"&gt;&lt;img src="doc-files/capchi.gif" alt="capchi"&gt; * &lt;img src="doc-files/captheta.gif" alt="captheta"&gt;&lt;img src="doc-files/capupsil.gif" alt="capupsil"&gt; * &lt;img src="doc-files/capsigma.gif" alt="capsigma"&gt;&lt;/td&gt; * &lt;td&gt;&lt;img src="doc-files/iota.gif" alt="iota"&gt;&lt;img src="doc-files/chi.gif" alt="chi"&gt; * &lt;img src="doc-files/theta.gif" alt="theta"&gt;&lt;img src="doc-files/upsilon.gif" alt="upsilon"&gt; * &lt;img src="doc-files/sigma1.gif" alt="sigma"&gt;&lt;/td&gt; * &lt;td&gt;lowercased all chars in String&lt;/td&gt; * &lt;/tr&gt; * &lt;/table&gt; * * @param locale use the case transformation rules for this locale * @return the &#123;@code String&#125;, converted to lowercase. * @see java.lang.String#toLowerCase() * @see java.lang.String#toUpperCase() * @see java.lang.String#toUpperCase(Locale) * @since 1.1 */ public String toLowerCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstUpper; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstUpper = 0 ; firstUpper &lt; len; ) &#123; char c = value[firstUpper]; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; int supplChar = codePointAt(firstUpper); if (supplChar != Character.toLowerCase(supplChar)) &#123; break scan; &#125; firstUpper += Character.charCount(supplChar); &#125; else &#123; if (c != Character.toLowerCase(c)) &#123; break scan; &#125; firstUpper++; &#125; &#125; return this; &#125; char[] result = new char[len]; int resultOffset = 0; /* result may grow, so i+resultOffset * is the write location in result */ /* Just copy the first few lowerCase characters. */ System.arraycopy(value, 0, result, 0, firstUpper); String lang = locale.getLanguage(); boolean localeDependent = (lang == "tr" || lang == "az" || lang == "lt"); char[] lowerCharArray; int lowerChar; int srcChar; int srcCount; for (int i = firstUpper; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent || srcChar == '\u03A3' || // GREEK CAPITAL LETTER SIGMA srcChar == '\u0130') &#123; // LATIN CAPITAL LETTER I WITH DOT ABOVE lowerChar = ConditionalSpecialCasing.toLowerCaseEx(this, i, locale); &#125; else &#123; lowerChar = Character.toLowerCase(srcChar); &#125; if ((lowerChar == Character.ERROR) || (lowerChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (lowerChar == Character.ERROR) &#123; lowerCharArray = ConditionalSpecialCasing.toLowerCaseCharArray(this, i, locale); &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(lowerChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; lowerCharArray = Character.toChars(lowerChar); &#125; /* Grow result if needed */ int mapLen = lowerCharArray.length; if (mapLen &gt; srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = lowerCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)lowerChar; &#125; &#125; return new String(result, 0, len + resultOffset); &#125; /** * */ public String toUpperCase(Locale locale) &#123; if (locale == null) &#123; throw new NullPointerException(); &#125; int firstLower; final int len = value.length; /* Now check if there are any characters that need to be changed. */ scan: &#123; for (firstLower = 0 ; firstLower &lt; len; ) &#123; int c = (int)value[firstLower]; int srcCount; if ((c &gt;= Character.MIN_HIGH_SURROGATE) &amp;&amp; (c &lt;= Character.MAX_HIGH_SURROGATE)) &#123; c = codePointAt(firstLower); srcCount = Character.charCount(c); &#125; else &#123; srcCount = 1; &#125; int upperCaseChar = Character.toUpperCaseEx(c); if ((upperCaseChar == Character.ERROR) || (c != upperCaseChar)) &#123; break scan; &#125; firstLower += srcCount; &#125; return this; &#125; /* result may grow, so i+resultOffset is the write location in result */ int resultOffset = 0; char[] result = new char[len]; /* may grow */ /* Just copy the first few upperCase characters. */ System.arraycopy(value, 0, result, 0, firstLower); String lang = locale.getLanguage(); boolean localeDependent = (lang == "tr" || lang == "az" || lang == "lt"); char[] upperCharArray; int upperChar; int srcChar; int srcCount; for (int i = firstLower; i &lt; len; i += srcCount) &#123; srcChar = (int)value[i]; if ((char)srcChar &gt;= Character.MIN_HIGH_SURROGATE &amp;&amp; (char)srcChar &lt;= Character.MAX_HIGH_SURROGATE) &#123; srcChar = codePointAt(i); srcCount = Character.charCount(srcChar); &#125; else &#123; srcCount = 1; &#125; if (localeDependent) &#123; upperChar = ConditionalSpecialCasing.toUpperCaseEx(this, i, locale); &#125; else &#123; upperChar = Character.toUpperCaseEx(srcChar); &#125; if ((upperChar == Character.ERROR) || (upperChar &gt;= Character.MIN_SUPPLEMENTARY_CODE_POINT)) &#123; if (upperChar == Character.ERROR) &#123; if (localeDependent) &#123; upperCharArray = ConditionalSpecialCasing.toUpperCaseCharArray(this, i, locale); &#125; else &#123; upperCharArray = Character.toUpperCaseCharArray(srcChar); &#125; &#125; else if (srcCount == 2) &#123; resultOffset += Character.toChars(upperChar, result, i + resultOffset) - srcCount; continue; &#125; else &#123; upperCharArray = Character.toChars(upperChar); &#125; /* Grow result if needed */ int mapLen = upperCharArray.length; if (mapLen &gt; srcCount) &#123; char[] result2 = new char[result.length + mapLen - srcCount]; System.arraycopy(result, 0, result2, 0, i + resultOffset); result = result2; &#125; for (int x = 0; x &lt; mapLen; ++x) &#123; result[i + resultOffset + x] = upperCharArray[x]; &#125; resultOffset += (mapLen - srcCount); &#125; else &#123; result[i + resultOffset] = (char)upperChar; &#125; &#125; return new String(result, 0, len + resultOffset); &#125; /** * */ public String toUpperCase() &#123; return toUpperCase(Locale.getDefault()); &#125; /** * 返回一个除掉 源字符串 两端空格的 新字符串对象 */ public String trim() &#123; int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; &#125; /** * This object (which is already a string!) is itself returned. * * @return the string itself. */ public String toString() &#123; return this; &#125; /** * Converts this string to a new character array. * * @return a newly allocated character array whose length is the length * of this string and whose contents are initialized to contain * the character sequence represented by this string. */ public char[] toCharArray() &#123; // Cannot use Arrays.copyOf because of class initialization order issues char result[] = new char[value.length]; System.arraycopy(value, 0, result, 0, value.length); return result; &#125; /** * Returns a formatted string using the specified format string and * arguments. * * &lt;p&gt; The locale always used is the one returned by &#123;@link * java.util.Locale#getDefault() Locale.getDefault()&#125;. * * @param format * A &lt;a href="../util/Formatter.html#syntax"&gt;format string&lt;/a&gt; * * @param args * Arguments referenced by the format specifiers in the format * string. If there are more arguments than format specifiers, the * extra arguments are ignored. The number of arguments is * variable and may be zero. The maximum number of arguments is * limited by the maximum dimension of a Java array as defined by * &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. * The behaviour on a * &#123;@code null&#125; argument depends on the &lt;a * href="../util/Formatter.html#syntax"&gt;conversion&lt;/a&gt;. * * @throws java.util.IllegalFormatException * If a format string contains an illegal syntax, a format * specifier that is incompatible with the given arguments, * insufficient arguments given the format string, or other * illegal conditions. For specification of all possible * formatting errors, see the &lt;a * href="../util/Formatter.html#detail"&gt;Details&lt;/a&gt; section of the * formatter class specification. * * @return A formatted string * * @see java.util.Formatter * @since 1.5 */ public static String format(String format, Object... args) &#123; return new Formatter().format(format, args).toString(); &#125; /** * Returns a formatted string using the specified locale, format string, * and arguments. * * @param l * The &#123;@linkplain java.util.Locale locale&#125; to apply during * formatting. If &#123;@code l&#125; is &#123;@code null&#125; then no localization * is applied. * * @param format * A &lt;a href="../util/Formatter.html#syntax"&gt;format string&lt;/a&gt; * * @param args * Arguments referenced by the format specifiers in the format * string. If there are more arguments than format specifiers, the * extra arguments are ignored. The number of arguments is * variable and may be zero. The maximum number of arguments is * limited by the maximum dimension of a Java array as defined by * &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;. * The behaviour on a * &#123;@code null&#125; argument depends on the * &lt;a href="../util/Formatter.html#syntax"&gt;conversion&lt;/a&gt;. * * @throws java.util.IllegalFormatException * If a format string contains an illegal syntax, a format * specifier that is incompatible with the given arguments, * insufficient arguments given the format string, or other * illegal conditions. For specification of all possible * formatting errors, see the &lt;a * href="../util/Formatter.html#detail"&gt;Details&lt;/a&gt; section of the * formatter class specification * * @return A formatted string * * @see java.util.Formatter * @since 1.5 */ public static String format(Locale l, String format, Object... args) &#123; return new Formatter(l).format(format, args).toString(); &#125; /** * Returns the string representation of the &#123;@code Object&#125; argument. * * @param obj an &#123;@code Object&#125;. * @return if the argument is &#123;@code null&#125;, then a string equal to * &#123;@code "null"&#125;; otherwise, the value of * &#123;@code obj.toString()&#125; is returned. * @see java.lang.Object#toString() */ public static String valueOf(Object obj) &#123; return (obj == null) ? "null" : obj.toString(); &#125; /** * Returns the string representation of the &#123;@code char&#125; array * argument. The contents of the character array are copied; subsequent * modification of the character array does not affect the returned * string. * * @param data the character array. * @return a &#123;@code String&#125; that contains the characters of the * character array. */ public static String valueOf(char data[]) &#123; return new String(data); &#125; /** * Returns the string representation of a specific subarray of the * &#123;@code char&#125; array argument. * &lt;p&gt; * The &#123;@code offset&#125; argument is the index of the first * character of the subarray. The &#123;@code count&#125; argument * specifies the length of the subarray. The contents of the subarray * are copied; subsequent modification of the character array does not * affect the returned string. * * @param data the character array. * @param offset initial offset of the subarray. * @param count length of the subarray. * @return a &#123;@code String&#125; that contains the characters of the * specified subarray of the character array. * @exception IndexOutOfBoundsException if &#123;@code offset&#125; is * negative, or &#123;@code count&#125; is negative, or * &#123;@code offset+count&#125; is larger than * &#123;@code data.length&#125;. */ public static String valueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; /** * Equivalent to &#123;@link #valueOf(char[], int, int)&#125;. * * @param data the character array. * @param offset initial offset of the subarray. * @param count length of the subarray. * @return a &#123;@code String&#125; that contains the characters of the * specified subarray of the character array. * @exception IndexOutOfBoundsException if &#123;@code offset&#125; is * negative, or &#123;@code count&#125; is negative, or * &#123;@code offset+count&#125; is larger than * &#123;@code data.length&#125;. */ public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count); &#125; /** * Equivalent to &#123;@link #valueOf(char[])&#125;. * * @param data the character array. * @return a &#123;@code String&#125; that contains the characters of the * character array. */ public static String copyValueOf(char data[]) &#123; return new String(data); &#125; /** * Returns the string representation of the &#123;@code boolean&#125; argument. * * @param b a &#123;@code boolean&#125;. * @return if the argument is &#123;@code true&#125;, a string equal to * &#123;@code "true"&#125; is returned; otherwise, a string equal to * &#123;@code "false"&#125; is returned. */ public static String valueOf(boolean b) &#123; return b ? "true" : "false"; &#125; /** * Returns the string representation of the &#123;@code char&#125; * argument. * * @param c a &#123;@code char&#125;. * @return a string of length &#123;@code 1&#125; containing * as its single character the argument &#123;@code c&#125;. */ public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true); &#125; /** * Returns the string representation of the &#123;@code int&#125; argument. * &lt;p&gt; * The representation is exactly the one returned by the * &#123;@code Integer.toString&#125; method of one argument. * * @param i an &#123;@code int&#125;. * @return a string representation of the &#123;@code int&#125; argument. * @see java.lang.Integer#toString(int, int) */ public static String valueOf(int i) &#123; return Integer.toString(i); &#125; /** * Returns the string representation of the &#123;@code long&#125; argument. * &lt;p&gt; * The representation is exactly the one returned by the * &#123;@code Long.toString&#125; method of one argument. * * @param l a &#123;@code long&#125;. * @return a string representation of the &#123;@code long&#125; argument. * @see java.lang.Long#toString(long) */ public static String valueOf(long l) &#123; return Long.toString(l); &#125; /** * Returns the string representation of the &#123;@code float&#125; argument. * &lt;p&gt; * The representation is exactly the one returned by the * &#123;@code Float.toString&#125; method of one argument. * * @param f a &#123;@code float&#125;. * @return a string representation of the &#123;@code float&#125; argument. * @see java.lang.Float#toString(float) */ public static String valueOf(float f) &#123; return Float.toString(f); &#125; /** * Returns the string representation of the &#123;@code double&#125; argument. * &lt;p&gt; * The representation is exactly the one returned by the * &#123;@code Double.toString&#125; method of one argument. * * @param d a &#123;@code double&#125;. * @return a string representation of the &#123;@code double&#125; argument. * @see java.lang.Double#toString(double) */ public static String valueOf(double d) &#123; return Double.toString(d); &#125; /** * Returns a canonical representation for the string object. * &lt;p&gt; * A pool of strings, initially empty, is maintained privately by the * class &#123;@code String&#125;. * &lt;p&gt; * When the intern method is invoked, if the pool already contains a * string equal to this &#123;@code String&#125; object as determined by * the &#123;@link #equals(Object)&#125; method, then the string from the pool is * returned. Otherwise, this &#123;@code String&#125; object is added to the * pool and a reference to this &#123;@code String&#125; object is returned. * &lt;p&gt; * It follows that for any two strings &#123;@code s&#125; and &#123;@code t&#125;, * &#123;@code s.intern() == t.intern()&#125; is &#123;@code true&#125; * if and only if &#123;@code s.equals(t)&#125; is &#123;@code true&#125;. * &lt;p&gt; * All literal strings and string-valued constant expressions are * interned. String literals are defined in section 3.10.5 of the * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;. * * @return a string that has the same contents as this string, but is * guaranteed to be from a pool of unique strings. */ public native String intern();&#125;]]></content>
      <categories>
        <category>Java源码</category>
      </categories>
      <tags>
        <tag>Java类详解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务管理]]></title>
    <url>%2F2019%2F07%2F27%2FMySQL%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务并非所有引擎都支持事务处理！ MyISAM和InnoDB是两种最常使用的引擎。MyISAM不支持明确的事务处理管理，而InnoDB支持。 事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。 几个术语：  事务（transaction）指一组SQL语句； 回退（rollback）指撤销指定SQL语句的过程； 提交（commit）指将未存储的SQL语句结果写入数据库表； 保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同） 控制事务管理事务处理的关键在于将SQL语句组分解为逻辑块，并明确规定数据何时应该回退，何时不应该回退。 12START TRANSACTION ; -- 该语句标志事务的开始ROLLBACK; -- 回退，取消事务 与 上一句 一起使用 事务处理用来管理INSERT、UPDATE和DELETE语句。你不能回退SELECT语句。（这样做也没有什么意义。）你不能回退CREATE或DROP操作(非行级 操作)。事务处理块中可以使用这两条语句，但如果你执行回退，它们不会被撤销。 COMMIT一般的MySQL语句都是直接针对数据库表执行和编写的。这就是所谓的隐含提交（implicit commit），即提交（写或保存）操作是自动进行的。但是，在事务处理块中，提交不会隐含地进行。为进行明确的提交，使用COMMIT语句明确提交。 123START TRANSACTION;sql_statement;COMMIT; -- 仅在sql_statement 中的语句都不出错时 才提交 隐含事务关闭 :当COMMIT或ROLLBACK语句执行后，事务会自动关闭（将来的更改会隐含提交）。 使用保留点更复杂的事务处理可能需要部分提交或回退。 为了支持回退部分事务处理，必须能在事务处理块中合适的位置放置占位符。这样，如果需要回退，可以回退到某个占位符。这些占位符称为保留点。 12SAVEPOINT point_name; -- 创建保留点ROLLBACK TO point_name; -- 退回保留点 保留点越多越好 可以在MySQL代码中设置任意多的保留点，越多越好。保留点越多，你就越能按自己的意愿灵活地进行回退。 释放保留点： 保留点在事务处理完成（执行一条ROLLBACK或COMMIT）后自动释放。自MySQL 5以来，也可以用RELEASE SAVEPOINT明确地释放保留点。 更改默认提交行为默认的MySQL行为是自动提交所有更改。换句话说，任何时候你执行一条MySQL语句，该语句实际上都是针对表执行的，而且所做的更改立即生效 12SET AUTOCOMMIT = 0; -- 修改自动提交-- 标志为连接专用 autocommit标志是 只针对每个连接(每个session), 而不是服务器的。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL游标与触发器]]></title>
    <url>%2F2019%2F07%2F27%2FMySQL%E6%B8%B8%E6%A0%87%E4%B8%8E%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[游标使用游标MySQL5添加对游标的支持。 游标（cursor）是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或做出更改。且MySQL的游标只能用于存储过程(与函数)。 你可以认为,游标就是一个迭代器， 帮助你去循环结果集里的每一行！ 使用游标涉及几个明确的步骤: 在能够使用游标前，必须声明（定义）它。这个过程实际上没有检索数据，它只是定义要使用的SELECT语句。 一旦声明后，必须打开游标以供使用。这个过程用前面定义的SELECT语句把数据实际检索出来。 对于填有数据的游标，根据需要取出（检索）各行。 在结束游标使用时，必须关闭游标。 在声明游标后，可根据需要频繁地打开和关闭游标。在游标打开后，可根据需要频繁地执行取操作 创建游标使用DECLARE语句创建(在存储过程PROCEDURE中，DECLARE除了声明变量之外还可以声明游标)。DECLARE命名游标，并定义相应的SELECT语句，根据需要带WHERE和其他子句。如下 1234567CREATE PROCEDURE procedure_name([variable])BEGIN DECLARE cursor_name CURSOR FOR #要点就在这一行 SELECT_SQL_STATEMENTEND;# 存储过程处理完成后，游标就消失（因为它局限于存储过程）# 在定义游标之后，可以打开它。 打开与关闭游标1234OPEN cursor_name;#在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动。CLOSE cursor_name;#CLOSE释放游标使用的所有内部内存和资源，因此在每个游标不再需要时都应该关闭。 隐含关闭： 如果你不明确关闭游标，MySQL将会在到达END语句时自动关闭它。 使用游标检索数据FETCH:在一个游标被打开后，可以使用FETCH语句分别访问它的每一行。FETCH指定检索什么数据（所需的列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条FETCH语句检索下一行（不重复读取同一行）。 12FETCH column_name INTO variable;# 默认从结果集 第一行开始检索 123456789101112131415161718#游标循环遍历 示例 (大写全为关键字)CREATE PROCEDURE p_name()BEGIN -- 声明两个变量，其中done 默认为 0 DECLARE done BOOLEAN DEFAULT 0; DECLARE o INT; DECLARE cursor1 CURSOR FOR-- 创建游标 SELECT order_num FROM orders; DECLARE CONTINUE HNADLER FOR SQLATATE &apos;设定值&apos; SET done=1; -- 声明循环处理器，当结果集中取出来的值 达到设定值后 将done设置为1 OPEN curor1; --打开游标 REPEAT FETCH cursor1 INTO o; -- 使用游标将 结果集中的值取出 放到o中 //此处可以插入任何你想要做的操作 UNTIL done END REPEAT; -- 知道done为真(1) 结束循环 CLOSE cursor1;END; 触发器触发器 也是在MySQL5之后才有的 如果你想要某条语句（或某些语句）在事件发生时自动执行，使用 触发器将是一个很好的选择。 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE； INSERT； UPDATE。除此之外的其他SQL语句不支持 创建触发器在创建触发器时，需要给出4条信息： 唯一的触发器名；（在整个数据库范围内唯一 ） 触发器关联的表；  触发器应该响应的活动（DELETE、INSERT或UPDATE）； 触发器何时执行（处理之前或之后）。 123456-- 如下示例CREATE TRIGGER trigger_name AFTER INSERT ON table_nameFOR EACH ROW （SELECT &apos;hh&apos;);-- INSERT 针对INSERT的触发器-- FOR EACH ROW 针对每个插入行-- 示例里的触发动作是 显示 hh(SELECT &apos;hh&apos;) 只有表 才支持 触发器！ 触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联。 触发器失败 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。 删除触发器1DROP TRIGGER trigger_name; 使用触发器INSERT触发器INSERT触发器在INSERT语句执行之前或之后执行。注意点: 在INSERT触发器代码内，可引用一个名为NEW的虚拟表(包含被插入德的行的数据)，访问被插入的行； 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）； 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。(可用于 确定新生成的值 SELECT NEW.coulumn_name) 将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。UPDATE触发器也是如如此。 DELETE触发器DELETE触发器在DELETE语句执行之前或之后执行。注意点： 在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行； OLD中的值全都是只读的，不能更新。 使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档，DELETE本身将被放弃。(BEFORE sql AFTER 任意一句执行失败，其后的都不能执行) 多语句触发器: 将FOR EACH ROW 后换为 BEGIN END块，好处是可以将多个 sql语句放在一起 UPDATE触发器UPDATE触发器在UPDATE语句执行之前或之后执行。注意点： 在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；  在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）； OLD中的值全都是只读的，不能更新。 触发器的小结创建审计跟踪：使用触发器，把更改（如果需要，甚至还有之前和之后的状态）记录到另一个表非常容易。 MySQL触发器中不支持CALL语句。这表示不能从触发器内调用存储过程。所需的存储过程代码需要复制到触发器内。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL英文文档常见单词学习]]></title>
    <url>%2F2019%2F07%2F27%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E6%96%87%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[MySQ技术文档中 常见的 计算机类英文单词语与短语。 单词与短语access controls（访问控制） mistakes，preventing（错误，防止） overview（概述） user accounts（用户账号）Administrators (管理)advantages of MySQL（MySQL的优点）AFTER versus BEFORE（AFTER与BEFORE）Against()aggregate functions （ 聚集函数） individual functions combining（组合） joins，utilizing（联结，利用） overview（概述）aliases（别名）alternative uses（替换使用）concatenating fields（拼接字段）naming（命名）table names（表名）ALL arguments（所有参数）ALTER TABLE statements（ALTER TABLE语句）ANALYZE TABLEanchors (regular expressions)（定位（正则表达式））AND operators（AND操作符）application filtering（应用过滤）AS keyword（AS关键字）ASC 升序asterisk wildcards（星号通配符）AUTO INCREMENT 自动增长auto increment（自动增量）autocommit flags（自动提交标志）AVG() 平均函数 backing up data（备份数据）basic character matching（基本字符匹配）BEFORE versus AFTER（BEFORE与AFTER）BETWEEN，49-50binary datatypes（二进制数据类型），304Boolean mode（布尔方式），170-175 calculated fields（计算字段）concatenating fields（拼接字段）mathematical calculations（数学运算）overview（概述）subqueries as（子查询作为计算字段）Cartesian products（笛卡儿积）case sensitivity（区分大小写）expression matching（表达式匹配）full-text searches（全文本搜索）sort orders（排序顺序）searches（搜索）statements（语句）character classes (regular expressions)matching（字符类（正则表达式），匹配）character matching（字符匹配）见matches (regular expressions)characters sets（字符集）overview（概述）working with（使用）CHECK TABLEclauses（子句）individual clausesclient-based results formatting（基于客户机的结果格式化）client-server software（客户机—服务器软件）collation sequences（校对顺序）overview（概述）working with（使用）column aliases（列别名）columns（列）commas between names（名字之间的逗号）definition of（定义）derived（推导出的）fully qualified names（完全限定名）INSERT statements（INSERT语句）padded spaces（填补空格）primary keys（主键）retrieving with SELECT（用SELECT检索）all（所有列）individual（单个列）multiple（多个列）separating correctly（正确分隔）sorting by multiple（按多个列排序）subquery result restrictions（子查询结果约束）combined queries，creating（组合查询，创建）command-line (mysql)（命令行（mysql））command-line utilities（命令行实用程序）commands （ 命令）individualcommandscommas between column names（列名之间的逗号）COMMENT keywords（COMMENT关键字）commits（提交）committing（提交）complex joins（复杂联结）compound queries（复合查询）creating（创建）overview（概述）rows ， eliminating/including duplicates（行，删除/包括复制））rules of（规则）sorting results（排序结果）WHERE clause combinations（WHERE子句组合）concatenating（拼接）column aliases（列别名）definition of（定义）fields（字段）mathematical calculations（数学计算）COUNT()COUNT() functions（COUNT()函数）DISTINCT arguments（DISTINCT参数）joins（联结）performing through subqueries（通过子查询执行）CREATECREATE TABLEengines（引擎）statements（语句）cross joins（叉联结）currency numbers，storing（货币数，排序），cursors（游标）creating（创建）FETCH statements（FETCH语句）opening/closing（打开/关闭）utilizing（利用）customers table（customers表） database client-server software interactions（数据库客户机—服务器软件的相互作用）databases（数据库）backing up（备份）compared to Database ManagementSystems(DBMSs)（与DBMS的比较）compared to schema（与模式的比较definition of（定义）maintenance performing（维护，执行）selecting with USE（用USE选择）datatypes（数据类型）binary datatypes（二进制数据类型）date and time datatypes（日期和时间数据类型）definition of（定义）numeric datatypes（数值数据类型）overview（概述）string datatypes（串数据类型）date and time manipulation functions（日期和时间处理函数）DBMSs (Database Management Systems)（数据库管理系统）compared to databases（与数据库比较）performance，improving（性能，改进）DECLARE statements（DECLARE语句）DEFAULT 缺省值DELAYED keywords（DELAYED关键字）DELETE statements（DELETE语句）DELETE triggers（DELETE触发器）delimiters（分隔符）derived columns（推导出的列）DESC 降序DESCRIBE 描述DISTINCT arguments（DISTINCT参数）retrieving distinct rows（检索不同的行）downloading MySQL（下载MySQL）DROP PROCEDUREDROP TABLE statement （DROP TABLE语句）DROP USER encoding（编码）engines（引擎）error codes（错误代码）expression matching（表达式匹配）matches (regular expressions) 匹配(有规律的表达式) FETCH statements（FETCH语句）fields (calculated)（字段（计算））columns 列(复数)concatenating fields（拼接字段）mathematical calculations（数学计算）FLUSH LOGS statements（FLUSH LOGS语句）FLUSH TABLES statements（FLUSH TABLES语句）foreign keys（外键）formatting（格式化）full-text searches（全文本搜索）Boolean mode（布尔方式）case sensitivity（区分大小写）enabling（启用）engine support（引擎支持）multiple search terms，ranking（多个搜索项，等级）overview（概述）performing（执行）query expansion（查询扩展）FULLTEXT clauses（FULLTEXT子句）fully qualified table names（完全限定的表名）functions（函数）date and time manipulation functions（日期和时间处理函数）numeric manipulation functions（数值处理函数），97数）GRANT statements（GRANT语句）simplifying multiple statements（简化多条语句）user accounts，creating（用户账号，创建）user rights（用户权限）GROUP BY 分组compared to ORDER BY（与ORDER BY比较）creating groups with（创建组）filtering groups with（过滤组） HAVING clauses（HAVING子句）IF NOT EXISTSIF statements（IF语句）IGNORE 忽略implicit commits（隐含提交）definition of（定义）utilizing in WHERE clauses（在WHERE子句中使用）IN BOOLEAN MODE，另见Boolean modeinner joins（内部联结）InnoDB 一个引擎名description of（描述）full-text searching suppor（ 全文本搜索支持）INSERT SELECT statement（INSERT SELECT语句）INSERT statement（INSERT语句）complete rows，inserting（完整行，插入）multiple rows，inserting（多个行，插入）overview（概述）performance of，improving（性能，改善）retrieved data，inserting（检索数据，插入）security privileges（安全权限）INSERT triggers（INSERT触发器）installing MySQL（安装MySQL） joins（联结）aggregate functions interaction（聚集函数相互作用）as system drags（使系统缓慢）Cartesian products（笛卡儿积）column names，qualifying（列名，限定）creating（创建）cross joins（叉联结）general guidelines（通用指南）inner joins（内部联结）multiple table joins（多表联结）natural joins（自然联结）outer joins（外部联结）overview（概述）purpose of（用途）referential integrity，maintaining（引用完整性，维护）self joins（自联结）views，simplifying with（视图，简化）WHERE clause importance（WHERE子句的重要性） keywords（关键字） left outer joins（左外部联结）LIKE operators（LIKE操作符）compared to REGEXP（与REGEXP比较）limitations of（限制）utilizing REGEXP like（使REGEXP类似于LIKE）LIMIThighest/lowest values，finding（最高/最低值，查找）retrieving rows（检索行）local servers，advantages of（本地服务器，优点）log files，reviewing（日志文件，查看）logical operators （ 逻辑操作符）logins (MySQL)（登录（MySQL））LOOP statements versus REPEAT statements（LOOP语句与REPEAT语句）LTRIM() function（LTRIM()函数） Match()，164-168matches (regular expressions)（匹配（正则表达式））[utilizing（使用）anchors（定位符，锚）character classes，matching（字符类，匹配）OR matches（OR匹配）repetition metacharacters（重复元字符），set matches（集合匹配）special characters，matching（特殊字符，匹配）mathematical calculations，performing（数学计算，执行）mathematical operators（数学操作符）MAX()MEMORYMIN()，MyISAMMySQL AdministratorsMySQL command-line（MySQL命令行）MySQL Query BrowserMySQL software（MySQL软件） names (fully qualified table names)（名字（完全限定表名））natural joins（自然联结）nested groups（嵌套组）non-numeric data（非数值数据）nonmatches（不匹配）NOTNULLchecking for with WHERE clauses（用WHERE子句检查）compared to nonmatches（不匹配比较）function interactions（函数相互作用）tables（表）versus empty strings（NULL与空串）wildcard searches（通配符搜索）numeric datatypes（数值数据类型）numeric manipulation functions（数值处理函数） operators（操作符）definition of（定义）full-text Boolean mode（全文本布尔方式）HAVING clause（HAVING子句）mathematical（数学）WHERE clauses（WHERE子句）OPTIMIZE TABLEORmatches（匹配）overview（概述）ORDER BYcase sensitivity in sort（排序中区分大小写）compared to GROUP BY clause（与GROUP BY子句比较）descending order（降序）highest/lowest values，finding（最高/最低值，查找）utilizing（利用）orders table（orders表）outer joins（外部连接） parameters（参数）parentheses（圆括号）grouping related operators（分组相关的操作符）INpasswords（口令）percent signs (wildcards)（百分号（通配符））portability (INSERT statements)（可移植性（INSERT语句））portable code（可移植代码）primary keys（主键）definition of（定义）tables（表）productnotes table（productnotes表）products table（products表） queries（查询），另见subqueries（子查询）building incrementally（增量地建立）calculated fields（计算字段）concatenating fields（拼接字段）mathematical calculations（数学计算）overview（概述）combining（组合）compound queries（复合查询）creating（创建）rows ， eliminating/including duplicates（行，删除/包括复制）rules of（规则）sorting results（排序结果）definition of（定义）formatting effectively（有效地格式化）WHERE clauses，combining with（WHERE子句，组合）Query Browser (MySQL)query expansion (full-text searches)（查询扩展（全文本搜索））quotes（引号）numeric datatypes（数值数据类型）string datatypes（串数据类型)utilizing in WHERE clauses（在WHERE子句中使用） range values，checking（范围值，检查）records compared to rows（记录与行比较）referential integrity，maintaining（引用完整性，维护）REGEXPregular expressions（正则表达式）basic character matching（基本字符匹配）limitations of（限制）matches（匹配），参见matches (regularexpressions)overview（概述）ranges，defining（范围，定义）testing（测试）whitespace metacharacters （ 空白元字符）relational tables（关系表）RENAME TABLEREPAIR TABLEREPEAT statements（REPEAT语句）repetition metacharacters (regular expressions)（重复元字符（正则表达式））reserved words（保留字）REVOKE statements（REVOKE语句）right outer joins（右外部联结）rollbacks（回退）ROLLUProot dangers（root的危险）rows（行）complete rows，inserting（完整行，插入）definition of（定义）duplicates，eliminating/including（复制,删除/包含））limiting retrieve results（限制检索结果）multiple rows，inserting（多行，插入）retrieving（检索）RTRIM() function（RTRIM()函数） savepoints（保留点）scalability（可伸缩性）schema（模式）scripts，executing（脚本，执行）searches（搜索）SELECT（查询）AS keyword（AS关键字）columns，retrieving（列，检索）all（全部列）individual（单个列）multiple（多个列）concatenating fields（拼接字段）purpose of（用途）sequencing（排序）self joins（自连接）semicolons（分号）server software（服务器软件）server-based results formatting（基于服务器的结果格式化）SET PASSWORD statements（SET PASSWORD语句）sets，matching regular expressions（集合，匹配正则表达式）SHOW sql关键字SHOW PROCEDURE STATUSsign values（符号值）signed datatypes（有符号的数据类型）sorting data（排序数据）by multiple columns（按多个列）case sensitivity（区分大小写）in descending order（以降序）overview（概述）SOUNDEX() function（SOUNDEX()函数）spaces，removing（空格，删除）special characters (regular expressions)（特殊字符（正则表达式））startup problems，diagnosing（启动问题，诊断)statement syntax（语句语法）statements（语句），另见individual statementsformatting（格式化）overview（概述）stopwords（非用词）stored procedures（存储过程）creating（创建）cursors（游标）disadvantages of（缺点）dropping（删除）executing（执行）inspecting（检查）intelligent stored procedures，building（智能存储过程，建立）overview（概述）parameters（参数）uses for（使用）string datatypes（串数据类型）subqueries（子查询），另见WHERE clausesas calculated fields（作为计算字段），combining queries with（查询与子查询组合）definition of（定义）filtering by（用子查询过滤）formatting effectively（有效地格式化order of process（处理次序）self joins（自联结）UPDATE statements（UPDATE语句）SUM()syntax（语法）joins（联结）statements（语句） tables（表）aliasing（起别名）AUTO INCREMENTcalculated fields（计算字段）concatenating fields（拼接字段）mathematical calculations （ 数学计算）overview（概述）Cartesian products（笛卡儿积）character sets，specifying（字符集，说明）creating（创建）customers table（customers表）default values，specifying（默认值，说明）DELETE statements（DELETE语句）deleting（删除）joins（联结）multiple tables，joining（多个表，联结）NULL values（NULL值）orderitems table（orderitems表）orders table（orders表）overview（概述）overwriting（覆盖）primary keys（主键）productnotes table（productnotes表）products table（products表）relational tables（关系表）renaming（重命名）updating（更新）vendors table（vendors表）views（视图）text（文本）text-manipulation functions（ 文本处理函数）time datatypes（时间数据类型）trailing space dangers in wildcards（通配符中尾空格的危险）transactions（事务处理）controlling（控制）engine support（引擎支持）overview（概述）triggers（触发器）BEFORE versus AFTER（BEFORE与AFTER）creating（创建）DELETE triggers（DELETE触发器）dropping（删除）failure of（故障）guidelines（指南）INSERT triggers（INSERT触发器）multi-statement triggers（多语句触发器）overview（概述）UPDATE triggers（UPDATE触发器）TRIM()trimming padded spaces（去头尾空格）TRUNCATE TABLE underscores (wildcards)（下划线（通配符））UNION operators（UNION操作符）compound queries 混合查询UNSIGNED keywords（UNSIGNED关键字）UPDATE statements（UPDATE语句）UPDATE triggers（UPDATE触发器）user accounts（用户账号）access rights，setting（访问权限，设置）creating（创建）deleting（删除）managing（管理）passwords，changing（口令，更改）renaming（重命名） VALUESvariables（变量）vendors table（vendors表）versions of MySQL（MySQL版本）views（视图）calculated fields（计算字段）common uses for（普通使用）complex joins，simplifying（复杂联结，简化）data，reformatting（数据，重新格式化）overview（概述）performance issues（性能问题）reusable views（可重用视图）creating（创建）rules and restrictions（规则和约束）unwanted data，filtering（不需要的数据，过滤）updating（更新）utilizing（利用） WHERE clauses（WHERE子句）checking against single values（检查单个值）checking for nonmatches（不匹配检查）combining（组合）combining AND/OR（组合AND/OR）combining queries（组合查询），compared to UNION（与UNION比较）dates，filtering by（日期，过滤）filtering groups（过滤组）importance of in joins（在联结中的重要性）INNOTNULL values（NULL值）operators（操作符）parentheses（圆括号）quotes，utilizing（引号，利用）range values，checking（范围值，检查）whitespace metacharacters（空白元字符）regular expressions（正则表达式）statements（语句）wildcards（通配符）guidelines for（指南）LIKE operator compared to REGEXP（LIKE操作符与REGEXP的比较）overview（概述）limitations of（限制）NULL interaction（与NULL的相互作用）overview（概述）trailing spaces，dangers of（尾空格，危险）WITH ROLLUP]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>MySQL文档中常见专业英语短语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据类型]]></title>
    <url>%2F2019%2F07%2F27%2FMySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据类型数据类型是定义列中可以存储什么数据以及该数据实际怎样存储的基本规则:数据类型用于以下目的: 数据类型允许限制可存储在列中的数据。例如，数值数据类型列只能接受数值。 数据类型允许在内部更有效地存储数据。可以用一种比文本串更简洁的格式存储数值和日期时间值。 数据类型允许变换排序顺序,不同的类型可以有不同的顺序。 在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失）。 串数据类型最常用的数据类型是串数据类型。它们存储串，如名字、地址、电。话号码、邮政编码等。 串又基本分为两种类型: 定长 与 变长 定长串接受长度固定的字符串，其长度是在创建表时指定的。定长列不允许多于指定的字符数目。它们分配的存储空间与指定的一样多。 变长串存储可变长度的文本。有些变长数据类型具有最大的定长，而有些则是完全变长的。不管是哪种，只有指定的数据得到保存（额外的数据不保存）TEXT属于变长串类型。 既然变长数据类型这样灵活，为什么还要使用定长数据类型？回答是因为性能。MySQL处理定长列远比处理变长列快得多。这也会极大地影响性能。 (此外，MySQL不允许对变长列（或一个列的可变部分）进行索引。–书中的该句 是错误的！ 你可以对VARCHAR类型字段添加索引的(ALTER TABLE ADD INDEX语句 )，再使用 SHOW INDEX FROM basename.tablename 可以看到索引是否添加成功) 12ALTER TABLE ADD INDEXSHOW INDEX FROM basename.tablename; --查看表中的索引 使用引号: 不管使用何种形式的串数据类型，串值都必须括在引号内（通常单引号更好）。 当数值不是数值时: 你可能会认为电话号码和邮政编码应该存储在数值字段中（数值字段只存储数值数据），但是，这样做却是不可取的。如果在数值字段中存储邮政编码01234，则保存的将是数值1234，实际上丢失了一位数字。 所以为数据选择正确的合适的类型是很有必要的。 数值数据类型数值数据类型存储数值。MySQL支持多种数值数据类型，每种存储的数值具有不同的取值范围。显然，支持的取值范围越大，所需存储空间越多。此外，有的数值数据类型支持使用十进制小数点（和小数），而有的则只支持整数。 有符号或无符号： 所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号。有符号数值列可以存储正或负的数值，无符号数值列只能存储正数。默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字，这样做将允许你存储两倍大小的值。 不使用引号: 与串不一样，数值不应该括在引号内。 存储货币数据类型： MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)—金融类应用使用的比较多 日期和时间数据类型MySQL使用专门的数据类型来存储日期和时间值 二进制数据类型二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL语法]]></title>
    <url>%2F2019%2F07%2F27%2FMySQL%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[MySQL语句的语法本小节摘自 MySQL必知必会 附录C 语句约定: |符号用来指出几个选择中的一个，因此，NULL | NOT NULL表示或者给出NULL或者给出NOT NULL。 包含在方括号[ ]中的关键字或子句（如[like this]）是可选的。 上述规则 在计算机文档中 通用！ ALTER TABLE:更新已存在表的模式。为了创建新表，应该使用CREATE TABLE。 123456ALTER TABLE tablename(ADD COLUMN columnname datatype [NULL | NOT NULL] [CONSTRAINTS],CHANGE COLUMN columnname datatype [NULL | NOT NULL] [CONSTRAINTS],DROP COLUMN columnname,.............); COMMIT: 提交事务 CREATE INDEX: 添加索引. 详细请参考 CREATE INDEX 12345CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name [index_type] ON tbl_name (key_part,...);key_part: &#123;col_name [(length)] | (expr)&#125; [ASC | DESC]-- 详细请参考 CREATE PROCEDURE:创建存储过程 1234CREATE PROCEDURE procedure_name ([parameters])BEGIN..............END CREATE TABLE：创建表 CREATE USER :创建MySQL用户 12CREATE USER &apos;username&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos;;-- @后的内容，如果被省略，则默认为 % CREATE VIEW:创建视图 123CREATE VIEW view_name [(column_list)] AS select_statement DELETE： 行级操作语句，删除表中的行 DROP: 永久删除数据库对象（表、视图、索引等) 1DROP type name; INSERT： 给表中插入数据 1INSERT INTO tablename[(clomunname)] VALUES(value); INSERT SELECT：将SELECT出的数据插入表中 ROLLBACK:回滚，撤销事务模块 SAVEPOINT: 为ROLLBACK语句设立的保存点 SELECT:查询数据 START TRANSACTION:开启事务 UPDATE:更新表中的数据 1UPDATE tablename SET columnname = value [WHERE condition]; 持续更新中………………..]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-数据库维护性能改善]]></title>
    <url>%2F2019%2F07%2F26%2FMySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%B4%E6%8A%A4%E4%B8%8E%E6%80%A7%E8%83%BD%E6%94%B9%E5%96%84%2F</url>
    <content type="text"><![CDATA[数据库维护备份数据由于MySQL数据库是基于磁盘的文件，普通的备份系统和例程就能备份MySQL的数据。但是，由于这些文件总是处于打开和使用状态，普通的文件副本备份不一定总是有效。 上述问题可解决方案: 使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。在进行常规备份前这个实用程序应该正常运行，以便能正确地备份转储文件。 可用命令行实用程序mysqlhotcopy从一个数据库复制所有数据（并非所有数据库引擎都支持这个实用程序)  可以使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。这两条语句都接受将要创建的系统文件名，此系统文件必须不存在，否则会出错。数据可以用RESTORE TABLE来复原。 首先刷新未写数据：为了保证所有数据被写到磁盘（包括索引数据），可能需要在进行备份前使用FLUSH TABLES语句。 数据库维护MySQL提供了一系列的语句，用来保证数据库正确和正常运行。 1234567891011121314151617181920ANALYZE TABLE tablename1[,tablename2,........]; -- 检查表键是否正确CHECK TABLE tablename1[,tablename2,........];-- 针对许多问题对表进行检查。在MyISAM表上还对索引进行检查。CHECK TABLE支持一系列的用于MyISAM表的方式。CHANGED tablename1[,tablename2,........]; -- 检查自最后一次检查以来改动过的表EXTENDED tablename1[,tablename2,........]; -- 执行最彻底的检查FAST tablename1[,tablename2,........]; -- 只检查未正常关闭的表MEDIUM tablename1[,tablename2,........]; -- 检查所有被删除的链接并进行键检验QUICK tablename1[,tablename2,........]; -- 只进行快速扫描-- 以下为官方文档原文CHECK TABLE tbl_name [, tbl_name] ... [option] ...option: &#123; FOR UPGRADE | QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;REPAIR TABLE; -- 如果MyISAM表访问产生不正确和不一致的结果，可能需要用 REPAIR TABLE来修复相应的表OPTIMIZE TABLE; -- 如果从一个表中删除大量数据，应该使用OPTIMIZE TABLE来收回所用的空间，从而优化表的性能。 诊断启动问题服务器启动问题通常在对MySQL配置或服务器本身进行更改时出现。MySQL在这个问题发生时报告错误，但由于多数MySQL服务器是作为系统进程或服务自动启动的，这些消息可能看不到。在排除系统启动问题时，首先应该尽量用手动启动服务器。MySQL服务器自身通过在命令行上执行mysqld启动。下面是几个重要的mysqld命令行选项： –help显示帮助——一个选项列表； –safe-mode装载减去某些最佳配置的服务器； –verbose显示全文本消息（为获得更详细的帮助消息与–help联合使用）； –version显示版本信息然后退出。 查看日志文件MySQL的主要日志文件有: 错误日志。它包含启动和关闭问题以及任意关键错误的细节。此日志通常名为hostname.err，位于data目录中。 查询日志。它记录所有MySQL活动，在诊断问题时非常有用。此日志文件可能会很快地变得非常大，因此不应该长期使用它。此日志通常名为hostname.log，位于data目录中。此名字可以用–log命令行选项更改。 二进制日志。它记录更新过数据（或者可能更新过数据）的所有语句。此日志通常名为hostname-bin，位于data目录内。此名字可以用–log-bin命令行选项更改。注意，这个日志文件是MySQL 慢查询日志。顾名思义，此日志记录执行缓慢的任何查询（可自主设置 多长时间为慢）。这个日志在确定数据库何处需要优化很有用。此日志通常名为hostname-slow.log ， 位于data 目录中。此名字可以用–log-slow-queries命令行选项更改。 改善性能 一般来说，关键的生产DBMS应该运行在自己的专用服务器上。  MySQL是用一系列的默认设置预先配置的，从这些设置开始通常是很好的。但过一段时间后你可能需要调整内存分配、缓冲区大小等。（为查看当前设置，可使用SHOW VARIABLES; 和SHOWSTATUS;。） MySQL一个多用户多线程的DBMS，换言之，它经常同时执行多个任务.如果某一个任务个执行缓慢，则所有请求都会执行缓慢。如果你遇到显著的性能不良，可使用SHOW PROCESSLIST显示所有活动进程（以及它们的线程ID和执行时间）。 KILL命令终结某个特定的进程（使用这个命令需要作为管理员登录）。 使用EXPLAIN语句让MySQL解释它将如何执行一条SELECT语句。(常用于查看慢查询日志中的 语句执行慢的问题)。 一般来说，存储过程执行得比一条一条地执行其中的各条MySQL语句快。  应该总是使用正确的数据类型。 决不要检索比需求还要多的数据。换言之，不要用SELECT *（除非你真正需要每个列）。  有的操作（包括INSERT）支持一个可选的DELAYED关键字，如果使用它，将把控制立即返回给调用程序，并且一旦有可能就实际执行该操作。 在导入数据时，应该关闭自动提交。你可能还想删除索引（包括FULLTEXT索引），然后在导入完成后再重建它们。 必须索引数据库表以改善数据检索的性能。确定索引什么不是一件微不足道的任务，需要分析使用的SELECT语句以找出重复的WHERE和ORDER BY子句。如果一个简单的WHERE子句返回结果所花的时间太长，则可以断定其中使用的列（或几个列）就是需要索引的对象。 如果你的SELECT语句中有一系列复杂的OR条件，通过使用多条SELECT语句和连接它们的UNION语句，你能看到极大的性能改进。 索引改善数据检索的性能，但损害数据插入、删除和更新(因为索引的维护也是需要时间的)的性能。如果你有一些表，它们收集数据且不经常被搜索，则在有必要之前不要索引它们。（索引可根据需要添加和删除。） LIKE很慢。一般来说，最好是使用FULLTEXT而不是LIKE。 数据库是不断变化的实体。一组优化良好的表一会儿后可能就面目全非了。由于表的使用和内容的更改，理想的优化和配置也会改变。 最重要的规则就是，每条规则在某些条件下都会被打破]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-安全管理]]></title>
    <url>%2F2019%2F07%2F26%2FMySQL-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[访问控制MySQL的安全基础：用户应该对他们需要的数据具有适当的访问权，既不能多也不能少。 需要给用户提供他们所需的访问权，且仅提供他们所需的访问权。这就是所谓的访问控制，管理访问控制需要创建和管理用户账号。 管理用户MySQL用户账号和信息存储在名为mysql的MySQL数据库中。 12USE mysql; -- 名为mysql的库SELECT user FROM user; -- 获取系统所有用户 创建用户账号: 12CREATE USER user_name IDENTIFIED BY &apos;password&apos;;-- INDENTIFIED BY 指定的为纯文本， 但是保存到USER表中时，会对其进行加密 使用GRANT或INSERT GRANT语句（稍后介绍）也可以创建用户账号，但一般来说CREATE USER是最清楚和最简单的句子。(最好不要用除这两个之外的 其他方法) 创建用户账号后，必须接着分配访问权限。新创建的用户账号没有访问权限。它们能登录MySQL，但不能看到数据，不能执行任何数据库操作。 重命名用户账号 1RENAME USER user_name TO new_name; -- 重命名一个用户 删除用户账号（及其权限） 1DROP USER user_name; -- 5以后的版本才能这样一步删除 访问权限123SHOW GRANTS FOR user_name; -- 查看该用户的权限-- 对root 用户执行该句 无效-- 若结果为 ON *.*，表示没有任何权限 设置权限:为设置权限，使用GRANT语句。GRANT要求你至少给出以下信息： 要授予的权限；(SELECT UPDATE DELETE ) 被授予访问权限的数据库或表；  用户名。 总结起来就是 ：为哪个用户在哪个表(库)上设置怎样的权限 12GRANT SELECT ON database_name.* TO user_name;# 给用户 user_na么 授予在 database_name库中所有表上 SELECT(只读) 的权限 GRANT的反操作为 REVOKE： 用于撤销权限 12REVOKE SELECT ON database_name.* FROM user_name;# 与 GRANT刚好相反。 被撤销的权限 必须存在，否则会报错 GRANT和REVOKE可在以下几个层次上控制访问权限：  整个服务器，使用GRANT ALL和REVOKE ALL； 整个数据库，使用ON database.；  *特定的表，使用ON database.table； **特定的列；  特定的存储过程。 更详细如下表所示: 简化多次授权:将权限 用,隔开 即可 12GRANT SELECT,INSERT ON database_name.* TO user_name;-- 给予 读取(select) 以及 插入(insert)数据 的权限 更改密码123SET PASSWORD FOR user_name=Password(&apos;new Password&apos;);-- 在没有 FOR 时，是为当前用户设置口令。 如下所示SET PASSWORD Password(&apos;new Password&apos;);]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL-全球化与本地化]]></title>
    <url>%2F2019%2F07%2F26%2FMySQL-%E5%85%A8%E7%90%83%E5%8C%96%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%8C%96%2F</url>
    <content type="text"><![CDATA[字符集和校对顺序数据库表被用来存储和检索数据。不同的语言和字符集需要以不同的方式存储和检索。因此，MySQL需要适应不同的字符集（不同的字母和符），适应不同的排序和检索数据的方法。 一些术语: 字符集为字母和符号的集合； 编码为某个字符集成员的内部表示； 校对为规定字符如何比较的指令。 普通SQL语句操作不用担心字符集的困扰。使用何种字符集和校对的决定在服务器、数据库和表级进行。 12SHOW CHARACTER SET; --展示 MySQL支持的字符集SHOW COLLATION; -- 展示更为完整的信息 通常系统管理在安装时定义一个默认的字符集和校对。此外，也可以在创建数据库时，指定默认的字符集和校对 12SHOW VARIABLE LIKE &apos;character%&apos;;SHOW VARIABLE LIKE &apos;character%&apos;; -- 查询 当前库，表所使用的字符集 实际上，字符集很少是服务器范围（甚至数据库范围）的设置。不同的表，甚至不同的列都可能需要不同的字符集，而且两者都可以在创建表时指定： 1234CREATE TABLE table_name(....);ENGING=InnoDB CHARACTER=utf8-- 卒后CHARACTER指定使用 utf8 不指定 则是使用数据库默认的字符集column_name ... .... CHARACTER SET utf8; -- 对某一列指定 字符集 ORDER BY column_name COLLATE utf8;--在排序时 指定用什么字符集排序 使用 COLLATE SELECT的其他COLLATE子句: 除了这里看到的在ORDER BY子句中使用以外，COLLATE还可以用于GROUP BY、HAVING、聚集函数、别名等。 如果绝对需要，串可以在字符集之间进行转换。为此，使用Cast()或Convert()函数。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java开发的一些小工具]]></title>
    <url>%2F2019%2F07%2F24%2FJava%E5%BC%80%E5%8F%91%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Java 读/写 Excel阿里巴巴开源工具：easyexcel Spring官网源码库 持续更新中……………………..]]></content>
      <categories>
        <category>日常Java开发会用到的工具</category>
      </categories>
      <tags>
        <tag>Java小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL视图与存储过程]]></title>
    <url>%2F2019%2F07%2F23%2FMySQL%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[视图View自MySQL5.0开始，MySQL添加对视图的支持。 视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。它本身并不存储数据，它只是相当于将别的SELECT语句查询出来的内容放在一个虚拟的表里。你可以将这个虚拟表看做一个实际的表，并从中取数据。 视图仅仅是用来查看存储在别处的数据的一种设施。视图本身不包含数据，因为它们返回的数据是从其他表中检索出来的。在添加或更改这些表中的数据时，视图将返回改变过的数据。 视图的应用视图的常见应用: 重用SQL语句。 简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。 使用表的组成部分而不是整个表。 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 在视图创建之后，可以用与表基本相同的方式利用它们。可以对视图执行SELECT操作，过滤和排序数据，将视图联结到其他视图或表，甚至能添加和更新数据。 性能问题: 因为视图不包含数据，所以每次使用视图时，都必须处理查询执行时所需的任一个检索。如果你用多个联结和过滤创建了复杂的视图或者嵌套了视图，可能会发现性能下降得很厉害。因此，在部署使用了大量视图的应用前，应该进行测试。(在实际工作中，视图基本不用，所以本节只做了解即可) 视图的规则和限制: 与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。 视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。 ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。 使用视图视图的基本语法: 视图用CREATE VIEW语句来创建。 使用SHOW CREATE VIEW viewname；来查看创建视图的语句。 用DROP删除视图，其语法为DROP VIEW viewname;。  更新视图时，可以先用DROP再用CREATE，也可以直接用CREATE OR REPLACE VIEW。如果要更新的视图不存在，则第2条更新语句会创建一个视图；新视图会替换原来已经存在的视图。 1234CTEATE VIEW view_name AS SELECT子句;#创建了一个名为view_name的视图。SELECT FROM view_name WHERE condition;#像使用一个表一样使用视图 视图极大地简化了复杂SQL语句(SELECT 子句可能比较复杂)的使用。利用视图，可一次性编写基础的SQL，然后根据需要多次使用。 你还可以利用视图先将数据格式(即使用SELECT语句格式化 将数据变为你想要的格式)。在需要这种格式的数据时，直接从视图中选出即可。 总之，你可将SELECT语句查询出的数据(包括格式化数据，过滤不想要的数据，对字段进行计算并将结果放在视图中) 变为一个视图 然后直接使用这个视图即可. 更新视图视图是可更新的(UPDATE DELETE INSERT)，在SELECT子句只是单纯的查询了表时视图可被更新。对视图的更新，也会对基表进行更新。 在MySQL不能正确地确定被更新的基数据，则不允许更新（包括插入和删除），因为都不能确定基数据，都不知道更新数，当然无法更新。即 视图定义中有以下操作，则不能进行视图的更新： 分组（使用GROUP BY和HAVING）； 联结； 子查询；  并；  聚集函数（Min()、Count()、Sum()等）； DISTINCT； 导出（计算）列。 上述严苛的条件，决定了，视图最大的用处只在于 检索！所以，应该将视图用于检索（SELECT语句）而不用于更新（INSERT、UPDATE和DELETE）。 小结视图为虚拟的表。视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据。 存储过程从MySQL5开始。 存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，虽然它们的作用不仅限于批处理。 使用存储过程的理由：简单(对直接使用者来说) 安全 高性能 通过把处理封装在容易使用的单元中，简化复杂的操作（View也一样）。 由于不要求反复建立一系列处理步骤，这保证了数据的完整性。如果所有开发人员和应用程序都使用同一（试验和测试）存储过程，则所使用的代码都是相同的。这一点的延伸就是防止错误。需要执行的步骤越多，出错的可能性就越大。防止错误保证了数据的一致性。  简化对变动的管理。如果表名、列名或业务逻辑（或别的内容）有变化，只需要更改存储过程的代码。使用它的人员甚至不需要知道这些变化。这一点的延伸就是安全性。通过存储过程限制对基础数据的访问减少了数据讹误（无意识的或别的原因所导致的数据讹误）的机会。 提高性能。因为使用存储过程比使用单独的SQL语句要快。 存在一些只能用在单个请求中的MySQL元素和特性，存储过程可以使用它们来编写功能更强更灵活的代码。 存储过程的一些缺陷: 存储过程的编写比基本SQL语句复杂，编写存储过程需要更高的技能，更丰富的经验。 使用存储过程MySQL称存储过程的执行为调用，因此MySQL执行存储过程的语句为CALL。CALL接受存储过程的名字以及需要传递给它的任意参数 12CALL procedure_name ([proc_parameter[,...])CALL procedure_name (); #无参的存储过程，但是 () 任然要带上 () 创建存储过程1234567891011CREATE [DEFINER = user] PROCEDURE sp_name ([proc_parameter[,...]])#参数可选 [COMMENT &quot;remark&quot;] # 备注可选 将在SHOW PROCEDURE STATUS时给出 BEGIB sql_statement; (-- 利用--可添加注释 DECALRE variable type; #定以变量 IF | ELSEIF variable THEN sql; #条件语句 使用条件语句使存储过程变得更加智能) END #注意：在mysql命令行客户机创建存储过程时,需要先使用 DELIMITER // 将命令结束符变为 // (临时更 改)，这样，存储过程体内的;仍然保持不动，并且正确地传递给数据库引擎。最后，为恢复为原来的语句分隔 符，可使用DELIMITER ;。除\符号外，任何字符都可以用作语句分隔符。 注意：在MySQL客户端 用命令行时，注意要先暂时 改变命令分隔符(结束符) 删除存储过程1234DROP PROCEDURE procedure_name;#该语句仅 当存储过程存在时能正确删除。否则将会报错. 安全期间可使用如下:DROP PROCEDURE IF EXISTS;# 多数删除之类的语句(表级操作)，都一般会带上 IF EXISTS，更加保险 使用参数存储过程可以接受参数(变量)， 也可以返回处理结果(变量)。 处理结果并不会直接显示，而是 将结果返回给你指定的变量。 变量（variable）内存中一个特定的位置，用来临时存储数据。 关键字OUT指出相应的参数用来从存储过程传出一个值（返回给调用者）。 MySQL支持IN（传递给存储过程）、OUT（从存储过程传出，即保存 SQL执行结果）和INOUT（对存储过程传入和传出）类型的参数。存储过程的代码位于BEGIN和END语句内，存储过程代码 即一系列的SQL语句， SQL语句执行后，通过 INTO param_name 将 值保存到 相应变量中。 参数的数据类型:存储过程的参数允许的数据类型与能在表中使用的数据类型相同 变量名： 所有MySQL变量都必须以@开始。 存储过程执行后， 它并不会直接返回结果，而是将结果返回到你指定的OUT，INOUT参数中。 1SELECT @out_pqaram; #跟在存储过程语句后面，即 获取存储过程的执行结果 检查存储过程12SHOW CREATE PROCEDORE procedure_name;# 为了获得包括何时、由谁创建等详细信息的存储过程列表，可使用如下SHOW PROCEDURE STATUS; 限制过程状态结果 SHOW PROCEDURE STATUS列出所有存储过程。为限制其输出，可使用LIKE指定一个过滤模式: 1SHOW PROCEDURE STATUS LIKE ＇procedure_name＇;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数操作表-table]]></title>
    <url>%2F2019%2F07%2F23%2FMySQL%E6%95%B0%E6%93%8D%E4%BD%9C%E8%A1%A8-table%2F</url>
    <content type="text"><![CDATA[创建和操纵表创建表MySQL不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。 创建表可直接使用SQl可视化工具(例如 Navicat，SQLyog等)创建(实际还是帮你生成创建的SQL语句，毕竟SQL服务器只认识SQL语句)，也可以使用SQL语句–CREATE TABLE创建(个人推荐！)。 使用CREATE TABEL创建一个表，需要以下信息:  新表的名字，在关键字CREATE TABLE之后给出； 表列的名字和定义，用逗号分隔。 123456789#示例语句CREATE TABLE table_name (column1(列名) int(指定数据类型) NOT NULL AUTO_INCREMENT(一些该列的限定规则),column2 char NOT NULL(一些该列的限定规则),........, PRIMARY KEY(column1,...... )(指定主键等))ENGINE=InnoDB CHARSET=utf8;#ENGINE=InnoDB 设置表的引擎(MySQL默认为InnoDB) 还可设置 字符集等# MySQL支持的数据类型 参见 MySQL数据类型# 创建表时，格式尽量清晰(如上所示，一行一行分明)，便于阅读与理解 如果你仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS。它只是查看表名是否存在，并且仅在表名不存在时创建它. 1CREATE TABLE table_name IF NOT EXIST ............. 使用NULL值:在创建表时 如果指定列为NOT NULL,则在插入数据时，该列一定要有具体值，否则会报错，且插入失败！ （没有NOT NULL的列则随意，没指定时默认为 NULL) 理解NULL: 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定。 即 只有 NULL才是真NULL，其他任意 均为非NULL。 主键再介绍主键值必须唯一！ 表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。迄今为止我们看到的CREATE TABLE例子都是用单个列作为主键。 使用单列: 12方式1: PRIMARY KEY(column_name)方式2: column_name type PRIMARY KEY 使用多列: 1PRIMARY KEY(column1,column2,........) #放在建表语句的括号内语句最后处即可 主键和NULL值:，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识 外键AUTO_INCREMENT最简单也是最高效的自增。 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。 覆盖AUTO_INCREMENT：你可以简单地在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将从你手动指定的值开始。 确定AUTO_INCREMENT值：在使用AUTO_INCREMENT时，你也可以使用函数last_insert_id() 来获取你所插入记录的 自增值！此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句。 猜想:MyBatis的 返回自增键[useGeneratedKeys=*”true”* keyProperty=*”id”]*可能**也是这个原理. 指定列的默认值如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定。 123colum1 int NOT NULL DEFAULT 1,# 如上所示， 该int型数据如果没有指定值， 则其默认值为1# DEFAULT 与 NOT NULL完全独立哦，两者并不是一定要同时出现。上面只是个例子而已 MySQL只支持 常量作为默认值，不允许函数为默认值。 使用默认值而不是NULL值: 许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。 引擎类型MySQL有一个具体管理和处理数据的内部引擎。 在创建语句最后的 ENGINE=InnoDB 即为指定该表的内部引擎为InnoDB。 MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎，这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。为什么要发行多种引擎呢？因为它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。 几个需要了解知道的引擎： InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索；  MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；  MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。 (InnoDB与MyISAM以及其他引擎当然还有其他不同差别，此处不再赘述)具体可查看对应官方文档。 引擎混用:同一个数据库里不同的表了可以使用不同的引擎以满足各自的需要。 外键不能跨引擎:混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。 就本人目前的短浅见识而言， InnoDB似乎是用的最多的(毕竟大多数业务是需要用到事务的)。你应该选以需求来为你的数据表选择最合适的引擎。在计算机领域，没有绝对完美的技术，只有最符合业务需求的技术。 人生也大概是这样吧， 更新表ALTER TABLE语句: 更新表定义。 理想状态下，当表中存储数据以后，该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。(所以设计数据库也是个很重要的东西 ) 使用ALTER TABLE，需要一下信息: 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）； 需要更改的列。 1234ALTER TABLE table_name ADD column_name type other;#顾名思义， 该命令给表 增添一列columnALTER TABLE table_name DROP COLUMN column_name;#删除表中的列 ALTER最常见的一直种用途 是 增加外键 定义. 123ALTER TABLE table_name ADD [CONSTRAINT [symbol]]FOREIGN KEY [index_name] (index_col_name,...) REFERENCES other_table(column_name,....)# []中的内容只作为参考选项，可有可无(计算机书籍里的通用规定) 精简一下: ALTER TABLE table_name ADD [CONSTRAINT [symbol]]FOREIGN KEY [index_name] (index_col_name,…) REFERENCES reference_table(column_name,….)； 复杂的表结构更改一般需要手动删除过程，它涉及以下步骤： 用新的列布局创建一个新表；  使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段； 检验包含所需数据的新表； 重命名旧表（如果确定，可以删除它）； 用旧表原来的名字重命名新表； 根据需要，重新创建触发器、存储过程、索引和外键。 小心使用ALTER TABLE 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。 删除表删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可： 1DROP TABLE table_name; #删除整个表了，当然同时也会删除其中的数据(与TRUNCATE 要注意区分) 重命名表: 1RENAME TABLE table_name TO new_table_name; 小结CREATE TABLE用来创建新表，ALTER TABLE用来更改表列（或其他诸如约束或索引等对象），而DROP TABLE用来完整地删除一个表。这些语句必须小心使用，并且应在做了备份后使用。本章还介绍了数据库引擎、定义主键和外键，以及其他重要的表和列选项。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数操作表-table]]></title>
    <url>%2F2019%2F07%2F23%2FMySQL%E6%93%8D%E4%BD%9C%E8%A1%A8-table%2F</url>
    <content type="text"><![CDATA[创建和操纵表创建表MySQL不仅用于表数据操纵，而且还可以用来执行数据库和表的所有操作，包括表本身的创建和处理。 创建表可直接使用SQl可视化工具(例如 Navicat，SQLyog等)创建(实际还是帮你生成创建的SQL语句，毕竟SQL服务器只认识SQL语句)，也可以使用SQL语句–CREATE TABLE创建(个人推荐！)。 使用CREATE TABEL创建一个表，需要以下信息: 新表的名字，在关键字CREATE TABLE之后给出； 表列的名字和定义，用逗号分隔。 123456789#示例语句CREATE TABLE table_name (column1(列名) int(指定数据类型) NOT NULL AUTO_INCREMENT(一些该列的限定规则),column2 char NOT NULL(一些该列的限定规则),........, PRIMARY KEY(column1,...... )(指定主键等))ENGINE=InnoDB CHARSET=utf8;#ENGINE=InnoDB 设置表的引擎(MySQL默认为InnoDB) 还可设置 字符集等# MySQL支持的数据类型 参见 MySQL数据类型# 创建表时，格式尽量清晰(如上所示，一行一行分明)，便于阅读与理解 如果你仅想在一个表不存在时创建它，应该在表名后给出IF NOT EXISTS。它只是查看表名是否存在，并且仅在表名不存在时创建它. 1CREATE TABLE table_name IF NOT EXIST (.............); 使用NULL值:在创建表时 如果指定列为NOT NULL,则在插入数据时，该列一定要有具体值，否则会报错，且插入失败！ （没有NOT NULL的列则随意，没指定时默认为 NULL) 理解NULL: 不要把NULL值与空串相混淆。NULL值是没有值，它不是空串。如果指定’’（两个单引号，其间没有字符），这在NOT NULL列中是允许的。空串是一个有效的值，它不是无值。NULL值用关键字NULL而不是空串指定。 即 只有 NULL才是真NULL，其他任意 均为非NULL。 主键再介绍主键值必须唯一！ 表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。迄今为止我们看到的CREATE TABLE例子都是用单个列作为主键。 使用单列: 12方式1: PRIMARY KEY(column_name)方式2: column_name type PRIMARY KEY 使用多列: 1PRIMARY KEY(column1,column2,........) #放在建表语句的括号内语句最后处即可 主键和NULL值:，主键为其值唯一标识表中每个行的列。主键中只能使用不允许NULL值的列。允许NULL值的列不能作为唯一标识. AUTO_INCREMENT最简单也是最高效的自增。 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如，通过使它成为主键）。 覆盖AUTO_INCREMENT：你可以简单地在INSERT语句中指定一个值，只要它是唯一的（至今尚未使用过）即可，该值将被用来替代自动生成的值。后续的增量将从你手动指定的值开始。 确定AUTO_INCREMENT值：在使用AUTO_INCREMENT时，你也可以使用函数last_insert_id() 来获取你所插入记录的 自增值！此语句返回最后一个AUTO_INCREMENT值，然后可以将它用于后续的MySQL语句。 猜想:MyBatis的 返回自增键[useGeneratedKeys=*”true”* keyProperty=*”id”]*可能**也是这个原理. 指定列的默认值如果在插入行时没有给出值，MySQL允许指定此时使用的默认值。默认值用CREATE TABLE语句的列定义中的DEFAULT关键字指定。 123colum1 int NOT NULL DEFAULT 1,# 如上所示， 该int型数据如果没有指定值， 则其默认值为1# DEFAULT 与 NOT NULL完全独立哦，两者并不是一定要同时出现。上面只是个例子而已 MySQL只支持 常量作为默认值，不允许函数为默认值。 使用默认值而不是NULL值: 许多数据库开发人员使用默认值而不是NULL列，特别是对用于计算或数据分组的列更是如此。 引擎类型MySQL有一个具体管理和处理数据的内部引擎。 在创建语句最后的 ENGINE=InnoDB 即为指定该表的内部引擎为InnoDB。 MySQL与其他DBMS不一样，它具有多种引擎。它打包多个引擎，这些引擎都隐藏在MySQL服务器内，全都能执行CREATE TABLE和SELECT等命令。为什么要发行多种引擎呢？因为它们具有各自不同的功能和特性，为不同的任务选择正确的引擎能获得良好的功能和灵活性。 几个需要了解知道的引擎： InnoDB是一个可靠的事务处理引擎（参见第26章），它不支持全文本搜索；  MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（特别适合于临时表）；  MyISAM是一个性能极高的引擎，它支持全文本搜索（参见第18章），但不支持事务处理。 (InnoDB与MyISAM以及其他引擎当然还有其他不同差别，此处不再赘述)具体可查看对应官方文档。 引擎混用:同一个数据库里不同的表了可以使用不同的引擎以满足各自的需要。 外键不能跨引擎:混用引擎类型有一个大缺陷。外键（用于强制实施引用完整性）不能跨引擎，即使用一个引擎的表不能引用具有使用不同引擎的表的外键。 就本人目前的短浅见识而言， InnoDB似乎是用的最多的(毕竟大多数业务是需要用到事务的)。你应该选以需求来为你的数据表选择最合适的引擎。在计算机领域，没有绝对完美的技术，只有最符合业务需求的技术。 人生也大概是这样吧， 更新表ALTER TABLE语句: 更新表定义。 理想状态下，当表中存储数据以后，该表就不应该再被更新。在表的设计过程中需要花费大量时间来考虑，以便后期不对该表进行大的改动。(所以设计数据库也是个很重要的东西 ) 使用ALTER TABLE，需要一下信息: 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则将出错）； 需要更改的列。 1234ALTER TABLE table_name ADD column_name type other;#顾名思义， 该命令给表 增添一列columnALTER TABLE table_name DROP COLUMN column_name;#删除表中的列 ALTER最常见的一直种用途 是 增加外键 定义. 123ALTER TABLE table_name ADD [CONSTRAINT [symbol]]FOREIGN KEY [index_name] (index_col_name,...) REFERENCES other_table(column_name,....)# []中的内容只作为参考选项，可有可无(计算机书籍里的通用规定) 精简一下: ALTER TABLE table_name ADD [CONSTRAINT [symbol]]FOREIGN KEY [index_name] (index_col_name,…) REFERENCES reference_table(column_name,….)； 复杂的表结构更改一般需要手动删除过程，它涉及以下步骤： 用新的列布局创建一个新表；  使用INSERT SELECT语句从旧表复制数据到新表。如果有必要，可使用转换函数和计算字段； 检验包含所需数据的新表； 重命名旧表（如果确定，可以删除它）； 用旧表原来的名字重命名新表； 根据需要，重新创建触发器、存储过程、索引和外键。 小心使用ALTER TABLE 使用ALTER TABLE要极为小心，应该在进行改动前做一个完整的备份（模式和数据的备份）。数据库表的更改不能撤销，如果增加了不需要的列，可能不能删除它们。类似地，如果删除了不应该删除的列，可能会丢失该列中的所有数据。 删除表删除表（删除整个表而不是其内容）非常简单，使用DROP TABLE语句即可： 1DROP TABLE table_name; #删除整个表了，当然同时也会删除其中的数据(与TRUNCATE 要注意区分) 重命名表: 1RENAME TABLE table_name TO new_table_name; 小结CREATE TABLE用来创建新表，ALTER TABLE用来更改表列（或其他诸如约束或索引等对象），而DROP TABLE用来完整地删除一个表。这些语句必须小心使用，并且应在做了备份后使用。本章还介绍了数据库引擎、定义主键和外键，以及其他重要的表和列选项。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据插入——INSERT]]></title>
    <url>%2F2019%2F07%2F22%2FMySQL--INSERT%2CUPDATE%2CDELETE%2F</url>
    <content type="text"><![CDATA[INSERT插入数据INSERT是用来插入（或添加）行到数据库表的。插入可以用几种方式使用： 插入完整的行； 插入行的一部分； 插入多行； 插入某些查询的结果 插入完整的列直接使用表名， 表中的每一列都必须提供一个值(NULL 或者 具体值)。 缺点:高度依赖表中列的定义次序 1234INSETR INTO table_name VALUES （NULL,value1,value2,value3,......）#表的第一列通常为 自增主键(也要给值NULL,MySQL会忽略这个NULL，自动插入一个自增id)。任何其他非空列(建表时设置了NOT NULL的)都应该给出具体值，允许为空的也要给出 NULL值# values的顺序与表中 列的顺序 必须一一对应# 该语句是有返回值的， 返回影响的 行数(一般插入几条记录 即 影响几行。) 插入行的一部分必须指定列名， 插入值得规则 同上。 123INSERT INTO table_name(column1,column2,column3,.......) VALUES(value1,value2,value3,.......);#列与值的顺序一一对应 value1--column1。VALUES必须以其指定的次序匹配指定的列名，不一定按各个列出现在实际表中的次序#自增主键值 是不需要指定的， MySQL插入数据时会自动处理 总是使用列的列表: 一般不要使用没有明确给出列的列表的INSERT语句。使用列的列表能使SQL代码继续发挥作用，即使表结构发生了变化。 仔细地给出列的值： 不管使用哪种INSERT语法，都必须给出VALUES的正确数目。如果不提供列名，则必须给每个表列提供一个值。如果提供列名，则必须对每个列出的列给出一个值。如果不这样，将产生一条错误消息，相应的行插入不成功。 可省略不给值的列: 如果表的定义允许，则可以在INSERT操作中省略某些列。省略的列必须满足以下某个条件。 该列定义为允许NULL值（无值或空值）。  在表定义中给出默认值。这表示如果不给出值，将使用默认值。 提高整体性能：INSERT LOW PRIORITY INTOINSERT操作可能很耗时（特别是有很多索引需要更新时），而且它可能降低等待处理的SELECT语句的性能.如果数据检索是最重要的（通常是这样），则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级. INSERT LOW PRIORITY INTO（此规则同样适用于UPDATE 与 DELETE）。 插入多个行批量插入数据。 1.使用多条INSERT语句，同时提交他们。个语句之间用 ; 隔开即可.就是多条单独的INSERT语句一起提交。2.VALUES之间用 , 隔开 1INSERT INTO table1 [ table(column1,column2,........)] VALUES (value1,value2,.....),(value21,value22,.....); 第二种能够 提高数据库处理的性能，因为MySQL用单条INSERT语句处理多个插入比使用多条INSERT语句快。 插入检索出的数据将一条SELECT语句的结果插入表中。这就是所谓的INSERT SELECT，顾名思义，它是由一条INSERT语句和一条SELECT语句组成的。 123INSERT INTO table| table(column1,column2,.....) SELECT 语句;#将SELECT语句的查询结果 插入到table中，注意列的类型值要兼容(最好一一对应)# 对列名无任何要求，主要是通过数据顺序来体填充的 小结记住格式: INSERT INTO table_name VALUES ………； UPDATE更新数据UPDATE语句可更新表中的数据。 不要省略WHERE子句: 在使用UPDATE时一定要注意细心。没有WHERE限定行，就会默认更新表中所有行。 UPDATE语句由3部分组成: 要更新的表，列名和它们的新值，确定要更新行的过滤条件(WHERE). 12UPDATE table_naem SET column1=value11,column2=value2,........ WHERE condition;# 指定更新满足条件的行的 指定列的值 UPDATE语句中可以使用子查询，使得能用SELECT语句检索出的数据更新列数据。(实际上子查询可以在任何你需要的地方使用) ## IGNORE关键字 如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消（错误发生前更新的所有行被恢复到它们原来的值）。为即使是发生错误，也继续进行更新，可使用IGNORE关键字，如下所示： 1UPDATE IGNORE .....................#直接跟在 UPDATE后面即可 谨慎使用! DELETE删除数据使用DELETE语句 可以从表中删除（去掉）数据。 不要省略WHERE子句:在使用DELETE时一定要注意细心。不指定条件，就会错误地删除表中所有行。 1DELETE FROM table_name WHERE conditon; DELETE是 数据操作，而不是表操作，删除的是表中的数据 而不是 表！ TRUNCATE关键字TRUNCATE可以让你更快的删除一个表中的所有数据(但执行完这条命令之后，表还在哦). 1TRUNCATE table_name; TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据. (哎，因为之前基本没接触过者个语句， 然后有一次面试的时候 懵了。(╥╯^╰╥)) 更新UPDATE 与 删除DELETE的原则 除非确实打算更新和删除每一行，否则绝对要使用带WHERE子句的UPDATE或DELETE语句。(WHERE子句不能忘！) 保证每个表都有主键，尽可能像WHERE子句那样使用它（可以指定各主键、多个值或值的范围）。 在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试，保证它过滤的是正确的记录，以防编写的WHERE子句不正确。 使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行。(例如 你删除的行的主键，被其他表作为外键引用了，在想删除时，MySQL就会发出警告)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL全文本搜索]]></title>
    <url>%2F2019%2F07%2F22%2FMySQL%E5%85%A8%E6%96%87%E6%9C%AC%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[全文本搜索理解全文本搜索并非所有引擎都支持全文本搜索。 MySQL支持几种基本的数据库引擎。并非所有的引擎都支持本书所描述的全文本搜索。两个最常使用的引擎为MyISAM和InnoDB，前者(MyISAM)支持全文本搜索，而后者(InnoDB)不支持。 已经学习过的“文本搜索”有: LIKE关键字，它利用通配操作符匹配文本（和部分文本）。使用LIKE，能够查找包含特殊值或部分值的行（不管这些值位于列内什么位置）。 REGEXP:使用正则表达式，可以编写查找所需行的非常复杂的匹配模式 虽然这些搜索机制非常有用，但存在几个重要的限制。 性能——通配符和正则表达式匹配通常要求MySQL尝试匹配表中所有行（而且这些搜索极少使用表索引，varchar()类型的数据很少会被建立索引）。因此，由于被搜索行数不断增加，这些搜索可能非常耗时。 明确控制——使用通配符和正则表达式匹配，很难（而且并不总是能）明确地控制匹配什么和不匹配什么。例如，指定一个词必须匹配，一个词必须不匹配，而一个词仅在第一个词确实匹配的情况下才可以匹配或者才可以不匹配。 智能化的结果——虽然基于通配符和正则表达式的搜索提供了非常灵活的搜索，但它们都不能提供一种智能化的选择结果的方法。例如，一个特殊词的搜索将会返回包含该词的所有行，而不区分包含单个匹配的行和包含多个匹配的行（按照可能是更好的匹配来排列它们）。类似，一个特殊词的搜索将不会找出不包含该词但包含其他相关词的行。 使用全文本搜索进行全文本搜索，必须索引被搜索的列，而且要随着数据的改变不断地重新索引。在对表列进行适当设计后，MySQL会自动进行所有的索引和重新索引。 在索引之后，SELECT可与Match()和Against()一起使用以实际执行搜索。 启用全文本搜索支持在创建表时，启用FULLTEXT。如下 1234567create table table_name(column_name type ......,............,FULLTEXT(column_name|需要文本搜索的列) #对该列开启文本搜索，如果需要也可以指定多个列)ENGINE=MyISAM; # InnoDB不支持文本搜索# 在定义之后，MySQL自动维护该索引。在增加、更新或删除行时，索引随之自动更新。 不要在导入数据时使用FULLTEXT ：更新索引要花时间，虽然不是很多，但毕竟要花时间。如果正在导入数据到一个新表，此时不应该启用FULLTEXT索引。应该首先导入所有数据，然后再修改表，定义FULLTEXT。这样有助于更快地导入数据。 进行全文本搜索两个函数 Match() Against():在索引之后，使用两个函数Match()和Against()执行全文本搜索，其中Match()指定被搜索的列，Against()指定要使用的搜索表达式。可用在WHERE子句中 Match()使用说明:传递给Match() 的值必须与FULLTEXT()定义中的相同。如果指定多个列，则必须列出它们（而且次序正确）。 12Match(column_name) Against(&apos;要搜索的文本内容&apos;)# 该搜索是有返回值的，返回值 包含全文本搜索计算出的等级值。等级由MySQL根据行中词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来 搜索不区分大小写： 除非使用BINARY方式（本章中没有介绍），否则全文本搜索不区分大小写 全文搜索对搜索的结果自动排序:全文本搜索的一个重要部分就是对结果排序。具有较高等级(你想要搜索的词在文本的更前面)的行先返回（因为这些行很可能是你真正想要的行），按等级以降序排序。 (有个 查询扩展，但暂时没懂意思) 布尔文本搜索 –更细致的查找MySQL支持全文本搜索的另外一种形式，称为布尔方式（boolean mode）。以布尔方式，需要提供关于如下内容的细节: 要匹配的词； 要排斥的词（如果某行包含这个词，则不返回该行，即使它包含其他指定的词也是如此）； 排列提示（指定某些词比其他词更重要，更重要的词等级更高）； 表达式分组； 另外一些内容。 即是没有FULLTEXT也可以使用。但这是一种非常缓慢的操作（其性能将随着数据量的增加而降低）。 语法: 1234Match(column_name) Against(&apos;要搜索的文本内容&apos; IN BOOLEAN MODE); #没有指定布尔操作符，因此，其结果与没有指定布尔方式的结果相同。Match(column_name) Against(&apos;text -test*&apos; IN BOOLEAN MODE); # 搜索含有text的数据，但是不要有 repo 的行# -排除一个词，而*是截断操作符（可想象为用于词尾的一个通配符 重要的: +: 包含，必须存在 -：必须不存在 * :词尾通配符 “ “:以整个短语匹配 排列而不排序: 在布尔方式中，不按等级值降序排序返回的行。即返回的结果是无序的. ## 全文本搜索的使用说明 关于全文本搜索的某些重要的说明。 在索引全文本数据时，短词被忽略且从索引中排除。短词定义为那些具有3个或3个以下字符的词（如果需要，这个数目可以更改）。  许多词出现的频率很高，搜索它们没有用处（返回太多的结果）。因此，MySQL规定了一条50%规则，如果一个词出现在50%以上的行中，则将它作为一个非用词忽略。50%规则不用于IN BOOLEAN MODE。 如果表中的行数少于3行，则全文本搜索不返回结果（因为每个词或者不出现，或者至少出现在50%的行中）。 忽略词中的单引号。例如，don’t索引为dont。 不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果。 如前所述，仅在MyISAM数据库引擎中支持全文本搜索。 MySQL带有一个内建的非用词(stopword)列表，这些次在索引全文本数据时总是被忽略]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL联合查询——UNION]]></title>
    <url>%2F2019%2F07%2F22%2FMySQL%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2--UNION%2F</url>
    <content type="text"><![CDATA[联合查询何利用UNION操作符将多条SELECT语句组合成一个结果集。 多数SQL查询都只包含从一个或多个表中返回数据的单条SELECT语句。MySQL也允许执行多个查询（多条SELECT语句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。 组合查询和多个WHERE条件: 多数情况下，组合相同表的两个查询完成的工作与具有多个WHERE子句条件的单条查询完成的工作相同。换句话说，任何具有多个WHERE子句的SELECT语句都可以作为一个组合查询给出。这两种技术在不同的查询中性能也不同。因此，应该试一下这两种技术，以确定对特定的查询哪一种性能更好。 创建组合查询可用UNION操作符来组合数条SQL查询。利用UNION，可给出多条SELECT语句，将它们的结果组合成单个结果集。 使用UNION：UNION的使用很简单。所需做的只是给出每条SELECT语句，在各条语句之间放上关键字UNION。结果集就是将 两条SQL的查询结果组合起来 即可。 UNION规则: UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句，将要使用3个UNION关键字）。 UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）。 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。 UNION从查询结果集中自动去除了重复的行（换句话说，它的行为与单条SELECT语句中使用多个WHERE子句条件一样） 去除重复行是UNION的默认行为，如果你想要留下所有的匹配行(不去重)，可使用UNION ALL; UNION 与 多WHEREUNION几乎总是完成与多个WHERE条件相同的工作。UNION ALL为UNION的一种形式，它完成WHERE子句完成不了的工作。如果确实需要每个条件的匹配行全部出现（包括重复行），则必须使用UNION ALL而不是WHERE。 UNION == 多个WHERE! 对组合查询结果排序SELECT语句的输出用ORDER BY子句排序。在用UNION组合查询时，只能使用一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。但是整个UNION结果集都起作用. 对于结果集，不存在用一种方式排序一部分，而又用另一种方式排序另一部分的情况，因此不允许使用多条ORDER BY子句。 使用UNION可极大地简化复杂的WHERE子句，简化从多个表中检索数据的工作。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL关联查询]]></title>
    <url>%2F2019%2F07%2F22%2FMySQL%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2JOIN%2F</url>
    <content type="text"><![CDATA[联结 表–JOINSQL最强大的功能之一就是能在数据检索查询的执行中联结（join）表。 关系表：将所有数据放在一个表中，绝对不是个好主意！关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系（relational））相关联。 外键(foreign key)：外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。(实质就是 另一个表的主键值！ 也是联系两个表的关键所在！) 外键(foreign key)的好处: 减少数据的重复。减少数据的改动。提供了更强的伸缩性. 可伸缩性（scale）： 能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。 为什么使用联结？分解数据为多个表能更有效地存储，更方便地处理，并且具有更大的可伸缩性。但这些好处是有代价的。如果数据存储在多个表中，怎样用单条SELECT语句检索出数据？ 答案是使用联结。简单地说，联结是一种机制，用来在一条SELECT语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。 维护引用完整性:通过在表的定义中指定主键和外键来实现.联结的两边，值一定要是相同的，这种强一致性关系，可由主键与外键来保证. 创建联结语法: 123SELECT column_name,...... FROM table_a,table_b WHERE table_a.column_name = table_b.column; #直接使用WHERE相等条件即可 通过 WHERE后的条件联结了 a,b两个表# 即 内联结，结果为两个表的交集 完全限定列名: 在引用的列可能出现二义性时（两个表中有同名的列，企且者两个列同时在一个SQL语句中使用），必须使用完全限定列名（用一个点分隔的表名和列名）。如果引用一个没有用表名限制的具有二义性的列名，MySQL将返回错误。 WHERE子句存在的必要性:在数据库表的定义中不存在能指示MySQL如何对表进行联结的东西。你必须自己做这件事情。在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。WHERE子句作为过滤条件，它只包含那些匹配给定条件（这里是联结条件）的行。没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。应该保证所有联结都有WHERE子句，否则MySQL将返回比想要的数据多得多的数据。同理，应该保证WHERE子句的正确性。不正确的过滤条件将导致MySQL返回不正确的数据。 笛卡尔积(cartesian product):由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数 乘以 第二个表中的行数(m * n) JOIN ON：上面的联结称为等值联结（equijoin），它基于两个表之间的相等测试。这种联结也称为内部联结。对于这种联结可以使用稍微不同的语法来明确指定联结的类型。即 INNER JOIN。在使用这种语法时，联结条件用特定的ON子句而不是WHERE子句给出。传递给ON的实际条件与传递WHERE的相同。 语法： 123SELECT column_name,... FROM table1 JOIN table2 ON table1.column_name = table2.column_name#FROM table1 JOIN table2 ON condition_exp;# 只有一个JION出现时，默认为 INNER JOIN 使用哪种语法? ANSI SQL规范首选INNER JOIN语法。此外，尽管使用WHERE子句定义联结的确比较简单，但是使用明确的联结语法能够确保不会忘记联结条件 联结多个表SQL对一条SELECT语句中可以联结的表的数目没有限制。创建联结的基本规则也相同。首先列出所有表，然后定义表之间的关系（WHERE后的条件增多而已） 性能考虑 :MySQL在运行时关联指定的每个表以处理联结。这种处理可能是非常耗费资源的，因此应该仔细，不要联结不必要的表。联结的表越多，性能下降越厉害。 部分子查询可以使用联结来替代！ 使用表别名别名除了用于列名和计算字段外，SQL还允许给表名起别名。这样做有两个主要理由： 缩短SQL语句；  允许在单条SELECT语句中多次使用相同的表。(一个表要使用多次时，可以起别名，起一个别名就可以将其看作一个全新的表，解决二义性) 外联结–LEFT/RIGTH [OUTER] JOIN在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字指定包括其所有行的表（RIGHT指出的是OUTER JOIN右边的表，而LEFT指出的是OUTER JOIN左边的表）. 简单点说就是:左外联结，左边表的数据记录全部存在于结果之中， 右边表的满足联结条件的才存在(右联结与 左联结刚好相反)。左联结可以通过颠倒FROM或WHERE子句中表的顺序转换为右外部联结。两种类型的外部联结可互换使用，而究竟使用哪一种纯粹是根据方便而定。 全联结–FULL JOIN两边的所有记录都在！ 能通过条件联结的 则结果以联结的形式存在， 不能通过连接的也存在，只是记录会 左/右 表的值全部为空。 小结：语法： 12FROM table_a (INNER[默认] | LEFT | RIGHT | FULL) JOIN table_b ON table_a.column = table_b.column;# 只有单独一个JOIN存在时，默认为INNER(内联结)，等同于直接使用WHERE来联结。结果为两个表的 交集。 LEFT/RIGHT JOIN 也叫外联结。 LEFT JOIN结果集 以左边 的为准，左表的所有记录都存在，右边表符合联结条件的记录存在。RIGHT则刚好相反。 可用通过交换 FROM子句和ON子句两边的表名 而使 左，右联结互换。 FULL JOIN 全联结： 两边的记录都完全存在结果集中。 能满足联结条件的以一种形式存在，不能满足的则单独存在！ ## 使用带聚集函数的联结 可以将联结后的结果集完全看做一张新表。就像对待一张普通表一样使用聚集函数即可 使用联结和联结条件某些要点: 注意所使用的联结类型。一般我们使用内部联结，但使用外部联结也是有效的。 保证使用正确的联结条件，否则将返回不正确的数据。 应该总是提供联结条件，否则会得出笛卡儿积。 在一个联结中可以包含多个表，甚至对于每个联结可以采用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据分组]]></title>
    <url>%2F2019%2F07%2F22%2FMySQL%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84-GROUP%20BY%2F</url>
    <content type="text"><![CDATA[分组数据从上一章可知，SQL聚集函数可用来汇总数据。这使我们能够对行进行计数，计算和与平均数，获得最大和最小值而不用检索所有数据。 分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。(从此句话可以看出，在逻辑上， 分组在前， 对数据进行其他计算在后) 创建分组GROUP BY分组是在SELECT语句的GROUP BY子句中建立的。 使用GROUP BY的一些注意事项 GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式。不能使用别名。 除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。(有点没懂意思) 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 12SELECT ..... WHERE ... GROUP BY .....ORDER BY ...;#根据顺序可以看出， GROUP BY是对WHERE删选过后的结果再次继续分组  对于GROUP BY指定列相同的数据记录， 查询结果中出现的数据为 表中的第一条记录(但是与你所看到的第一条数据，还是可能会存在差异)因为单纯的SELECT语句，并不对查询结果的顺序做任何保证， 所以建议去查询 排序后的数据以保证结果一定如你预期所想！) 一道SQL面试题:表table1中有id(主键，自增)a,b,c,d五列， 请删除a,b,c,d数据出现重复的列，只留下其中 id最小的那行记录. 分析：只留下最id最小的那行记录，可以先找出 id最小的记录， 然后拿出id,将所有记录中 id不在其中的列全部删除即可。找出id最小的列，则可以使用我们刚学的GROUP BY, 将记录按a,b,c,d分组即可，再将该结果作为子结果，继续查询 SELECT出id值即可！ (一提到去重，最先想到的肯定是DISTICT去重， 但是DISTINCT有个缺点，查询出来的字段只有DINSTINCT中出现的字段! 所以也就导致我们无法选出最小的那个id了) 12SELECT DISTINCT vend_id,prod_price,..... FROM table1;#查询结果只有vend_id 和 prod_price等DISTINCT后出现过的字段 SQL语句如下： 1234DELETE FROM table1 WHERE id NOT IN (SELECT id FROM(SELECT * FORM (SELECT * FROM table1 ORDER BY id ASC) A GROUP BY a,b,c,d) B ); # ORDER BY 为了更好的控制结果顺序。千万不要依赖非 ORDER BY去保证数据的正确顺序性# 如果您有更好的想法，可在下方留言，一起交流学习# 在具体对该语句进行测试时，发现没有达到预期的效果。暂时也没有找到是什么原因，如果有小伙伴知道烦请留言讨论告知 HAVINGHAVIGN :只跟在 GROUP BY之后 。对GROUP BY后的结果 进行筛选 HAVING支持所有的WHERE操作符，可以看作是 GROUP BY的专用条件筛选。 HAVING 与 WHERE的差别:，WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。 GROUP BY 与 ORDER BY不要忘记ORDER BY :一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法。千万不要仅依赖GROUP BY排序数据。 SELECT各子句的顺序 子 句 说 明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 总是后面的子句， 对前面的子句的结果进行操作！(SELECT 不在这五行之中,不使用该规则。) 使用子查询什么是子查询子查询(subquery):即嵌套在其他查询中的查询。其结果是别人的查询依据(相当于 结果组成一个新表， 其他查询以这个新表为依据进行查询) 一条SELECT语句返回的结果用于另一条SELECT语句的WHERE子句。 逐渐增加子查询来建立查询: 用子查询测试和调试查询很有技巧性，特别是在这些语句的复杂性不断增加的情况下更是如此。用子查询建立（和测试）查询的最可靠的方法是逐渐进行，这与MySQL处理它们的方法非常相同。首先，建立和测试最内层的查询。然后，用硬编码数据建立和测试外层查询，并且仅在确认它正常后才嵌入子查询。这时，再次测试它。对于要增加的每个查询，重复这些步骤。这样做仅给构造查询增加了一点点时间，但节省了以后（找出查询为什么不正常）的大量时间，并且极大地提高了查询一开始就正常工作的可能性。 从里到外，查询要一层一层建立起来！这样思路也更清晰，分析也更容易。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用函数--对字段进行处理]]></title>
    <url>%2F2019%2F07%2F21%2FMySQL%E5%AF%B9%E5%AD%97%E6%AE%B5%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86--%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[计算字段存储在数据库表中的数据可能不是应用程序所需要的格式。想要将数据变成想要的格式， 一是可以在应用层处理数据， 二则是直接在SQL中处理就好。 但是 让客户机应用（或开发语言）处理数据库的工作将会极大地影响用的性能，并且使所创建的应用完全不具备可伸缩性。此外，如果在客户机上过滤数据，服务器不得不通过网络发送多余的数据，这将导致网络带宽的浪费。一般来说，在数据库服务器上完成这些操作比在客户机中完成要快得多，因为DBMS是设计来快速有效地完成这种处理的。因此建议，能通过SQL处理则尽量通过SQL处理，即SQL对字段进行进行计算。 字段（field） 基本上与列（column）的意思相同，经常互换使用，不过数据库列一般称为列，而术语字段通常用在计算字段的连接上。 拼接字段-concat()函数拼接（concatenate） 将值联结到一起构成单个值。 在MySQL的SELECT语句中，可使用concat()函数来拼接两个列。 MySQL的不同之处 :多数DBMS使用+或||来实现拼接，MySQL则使用Concat()函数来实现。当把SQL语句转换成MySQL语句时一定要把这个区别铭记在心. concat()拼接串，即把多个串连接起来形成一个较长的串。 concat()需要一个或多个指定的串，各个串之间用逗号分隔。 别名-AS别名（alias）是一个字段或值的替换名。别名用AS关键字赋予。 SELECT colum_name (AS) aa ;#也可以不用as，直接写别名就行. 任何客户机应用都可以按名引用这个列，就像它是一个实际的表列一样。 算术计算MySQL支持+(加),-(减),*(乘)，/(除)四种基本算术操作符。加上括号可以用来区分优先顺序。 SELECT NOW();#返回当前系统时间 数据处理函数SQL支持利用函数来处理数据。函数一般是在数据上执行的，它给数据的转换和处理提供了方便。TRIM()就是一个函数例子 函数没有SQL的可移植性强:几乎每种主要的DBMS的实现都支持其他实现不支持的函数，而且有时差异还很大。如果不使用这些函数，编写某些应用程序代码会很艰难。如果你决定使用函数，应该保证做好代码注释，以便以后你（或其他人）能确切地知道所编写SQL代码的含义。 使用函数大多数SQL实现支持以下类型的函数。 用于处理文本串（如删除或填充值，转换值为大写或小写）的文本函数。  用于在数值数据上进行算术操作（如返回绝对值，进行代数运算）的数值函数。  用于处理日期和时间值并从这些值中提取特定成分（例如，返回两个日期之差，检查日期有效性等）的日期和时间函数。  返回DBMS正使用的特殊信息（如返回用户登录信息，检查版本细节）的系统函数。 文本处理函数TRIM()：处理掉文本左右两边的空格 (类似的还有LTRIM(), RTRIM()) UPPER():将文本转化为大小.(当然只支持 英文文本串) Left() 返回串左边的字符 Right() 返回串右边的字符 Length() 返回串的长度 Locate() 找出串的一个子串 Upper() 将串转换为大写 Lower() 将串转换为小写 Trim() 去掉串两边的空格 LTrim() 去掉串左边的空格 RTrim() 去掉串右边的空格 Soundex() 返回串的SOUNDEX值 SubString() 返回子串的字符 由于平时Soundex()用的比较少，所以特此解释一下:SOUNDEX是一个将任何文本串转换为描述其语音表示的字母数字模式的算法。SOUNDEX考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。虽然SOUNDEX不是SQL概念，但MySQL（就像多数DBMS一样）都提供对SOUNDEX的支持。(其实主要是用在英文上的，测试了一下， 对中文没有明显效果！) 使用： SELECT column_name FROM table_name WHERE Soundex(column_name) = Soundex(‘concreteStirng’); 日期时间处理函数日期和时间采用相应的数据类型和特殊的格式存储，以便能快速和有效地排序或过滤，并且节省物理存储空间。 日期和时间函数在MySQL语言中具有重要的作用。 注意MySQL使用的日期格式:无论你什么时候指定一个日期，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。 数值处理函数数值处理函数仅处理数值数据。这些函数一般主要用于代数、三角或几何运算，因此没有串或日期—时间处理函数的使用那么频繁。 在主要DBMS的函数中，数值函数是最一致最统一的函数 Abs() 绝对值 Exp() 指数值 Mod() 取余 Sqrt() 开方， 这几个要重点记住。 其他详细可参考 MySQL函数的使用 统计函数对数据进行需要的汇总而不是实际把他它们检索出来。为此MySQL提供了专门的函数。使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成。这些检索函数主要有以下几种：􀂉 确定表中行数（或者满足某个条件或包含某个特定值的行数）。􀂉 获得表中行组的和。 􀂉 找出表列（或所有行或某些特定的行）的最大值、最小值和平均值。 常用聚集函数: AVG(table_name) 返回某列的平均值 COUNT(table_name | *) 返回某列(所有列)的行数 MAX(table_name) 返回某列的最大值 MIN(table_name) 返回某列的最小值 SUM(table_name) 返回某列值之和 注意:AVG() COUNT(table_name) MAX() MIN() SUM() 均忽略 列值为 NULL的行 COUNT(*) 则不忽略 (因为只要一行记录存在，其中肯定有不为 NULL的列) 聚集不同的值:以上5个聚集函数都可以如下使用：􀂉 对所有的行执行计算，指定ALL参数或不给参数（因为ALL是默认行为）；􀂉 要加入的值 只包含不同的值，指定DISTINCT参数。 (其中，使用DISTINCT 对 AVG()平均数的影响最大)， 因为可能会使众多 值小(大)的值 只出现一次， 从而拉低或者抬高 平均值。 例如：SELECT AVG(DINTINCT(column_name)) FROM table_name; # column_name的中不同的值只会出现一次，AVG()统计的也是所有不同的值的平均值。 注意 :如果指定列名，则DISTINCT只能用于COUNT()。DISTINCT不能用于COUNT(*)，因此不允许使用COUNT（DISTINCT），否则会产生错误。类似地，DISTINCT必须使用列名，不能用于计算或表达式。 聚合函数组合:多个函数可组合在一起使用，各自会发挥各自的功能。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式必知必会]]></title>
    <url>%2F2019%2F07%2F21%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL过滤数据]]></title>
    <url>%2F2019%2F07%2F21%2FMySQL%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[MySQL过滤数据WHERE 子句数据库表一般包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（search criteria），搜索条件也称为过滤条件（filter condition）。 在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。WHERE子句在表名（FROM子句）之后给出： 1SELECT** column_name[,....,.....] \|| * **FROM** table_name **WHERE** condition_expression **ORDER BY** column_name DESC|ASC; WHERE子句的位置: 在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于WHERE之后，否则将会产生错误 WHERE子句操作符： 除了常规的大于等于小于及其组合之外， 还有一个BETWEEN(范围值检查,在指定的两个值之间,BETWEEN匹配范围中所有的值，包括指定的开始值和结束值) BETWEEN123#语法WHERE column_ name BETWEEN value1 AND value2;#选出来的结果值 包含value1 和 value2 空值检查：NULLNULL 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同 SELECT语句有一个特殊的WHERE子句，可用来检查具有NULL值的列。这个WHERE子句就是IS NULL子句 12WHERE column_ name IS NULL;#用来检查具有NULL值的列 组合WHERE子句AND:两个WHERE条件子句同时成立 OR:**只要有一个WHERE子句**条件成立****就行 语法：WHERE expression_condition1 AND || OR expression_condition2 WHERE子句 AND 与 OR 执行顺序:WHERE可包含任意数目的AND和OR操作符。允许两者结合以进行复杂和高级的过滤。但是任意 结合也会来一个问题–各子句的执行先后问题。(想象一下，如同你小学时候学会了加减乘除，加减/乘除 各自单独放在一起， 完全不会出现 计算顺序的先后问题，都是从左往右顺序执行。 但是你若将 加减/乘除 组合在一起，此时的执行顺序就不是 从左往右先前再后的顺序那么简单了。 AND 与 OR 组合在一起，也是如此！) 12#例句：SELECT prod_name,prod_price FROM products WHERE vend_id=1002 OR vend_id=1002 AND prod_price &gt;= 10; 如上,查询出来的结果并非会完全如你所想， 先 vend_id=1002 再 vend_id=1002 最后再 prod_price &gt;= 10 来对前两步的结果进行删选。 但事与愿违，你可能会发现最终的结果里面有 prod_price &lt; 10 的记录。因为 这句事实上的执行顺序为：SELECT prod_name,prod_price FROM products [WHERE vend_id=1002 OR (vend_id=1002 AND prod_price &gt;= 10)]; AND 在 OR前面先执行， 如同乘除法 在 加减法 前执行一样，计算是有次序的， AND 与 OR 的优先级并不一样。 注意:SQL（像多数语言一样）在处理OR操作符前，优先处理AND操作符. AND &gt; OR 要想SQL语句完全按照自己所想的顺序来执行。最简单也是最有效的，即 加() 限定 执行顺序(在任何你不确定顺序的情况下，加上括号() 来限定，是完全有保证的！) 改造:SELECT prod_name,prod_price FROM products WHERE (vend_id=1002 OR vend_id=1002) AND prod_price &gt;= 10;#当然你之际诶把 prod_price &gt;= 10 放在最前面也是OK的。 IN操作符IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取合法值的由逗号分隔的清单，全都括在圆括号中。 IN与OR 完成的是同一种功能！ 但是在某些情况下，IN比OR要更简洁！ 为什么要使用IN操作符？其优点具体如下。 在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。 在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。 IN操作符一般比OR操作符清单执行更快。  IN的最大优点是可以包含其他SELECT语句(子查询)，使得能够更动态地建立WHERE子句。 NOT操作符WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所跟的任何条件！ NOT WHERE子句中用来否定后跟条件的关键字。 MySQL中的NOT: MySQL支持使用NOT 对IN 、BETWEEN 和EXISTS子句取反 包括： NOT IN, NOT BETWEEN, NOT EXISTS等 通配符过滤LIKE 操作符利用通配符可创建比较特定数据的搜索模式。(最常 用于varchar类型的数据比较，即字符串的比较) 通配符本身实际是SQL的WHERE子句中有特殊含义的字符，SQL支持几种通配符。 百分号（%）通配符%表示任何字符出现任意次数(0,1,n)(区分大小写的哦。除了一个或多个字符外，%还能匹配0个字符。%代表搜索模式中给定位置的0个、1个或多个字符。(注意尾空格，最后的空格也算是一个字符的,。解决这个问题的一个简单的办法是在搜索模式最后附加一个%。一个更好的办法是使用函数（trim())去掉前后两边的空格, RTrim()去掉右边的空格，LTrim()去掉左边的空格)。 下划线（_）通配符下划线的用途与%一样，下划线只匹配单个字符而不是多个字符。 通配符使用技巧1.过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。2.确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。尽量把这种模糊搜索条件放在最后。 3.注意通配符的位置。如果放错地方，可能不会返回想要的数据 利用正则表达式搜索正则表达式介绍正则表达式是用来匹配文本中的特殊的串（字符集合），删选出一段字符串中 是否含有执行特殊类型字符串(可以看做是一种更精准的匹配) 使用MySQL正则表达式正则表达式的作用是匹配文本，将一个模式（正则表达式）与一个文本串进行比较。MySQL用WHERE子句对正则表达式提供了初步的支持，允许你指定正则表达式，过滤SELECT检索出的数据。 语法:REGEXP使用语法：WHERE column_name REGEXP ‘正则表达式’; REGEXP后所跟的东西作为正则表达式（与文字正文1000匹配的一个正则表达式）处理。 匹配不区分大小写： MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写（即，大写和小写都匹配）。为区分大小写，可使用BINARY关键字，如WHERE prod_name REGEXP BINARY ‘JetPack .000’。 REGEXP BINARY 区分大小写。 具体只要熟悉 正则表达式的写法就行。 主要就是记住 MySQL有这么个功能，有 REGEXP [BINARY] 关键字。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL查询数据]]></title>
    <url>%2F2019%2F07%2F20%2FMySQL%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[查询数据SQL语句是由简单的英语单词构成的。这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成的。最经常使用的SQL语句就是SELECT语句。它的用途是从一个或多个表中检索信息。 SELECT使用SELECT语句，至少要提供两条信息—–想获取什么信息，以及从什么地方获取信息。 语法：*SELECT column_name,………[表示所有列] FROM table_name； *#多列之间用逗号(,) 隔开，最后一个列名后不需要加逗号 注意:如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的。 DISTINCT用于检索不同行， 查询结果为 指定列 的内容值只出现一次。 次关键字指示 MySQL值返回不同的值。 输入：SELECT DISTINCT column_name,……… FORM table_name;分析:SELECT DISTINCT column_name 告诉MySQL只返回不同（唯一）的column_name 行. DISTICT： 也可以看作是一种 按列值分组，因为每一个值 只出现一次，当然可以看作是一种分组(将结果作为一个子表，再查询统计这个子表即可) 12SELECT COUNT(a) FROM (SELECT DISTINCT `a`,`b` from `runoob_tbl`) A;#查找表中 a列 的总数 注意:如果使用DISTINCT关键字，它必须直接放在列名的前面 LIMIT返回指定的行 LIMIT X; 从结果的第一行开始,返回结果不多于 X行。 LIMIT X,Y; 从第X行开始(不含第X行)，返回不多于 Y行。 排序查询数据单纯用SELECT语句查询出来的数据，其输出并没有特定的顺序。 检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的顺序。但是，如果数据后来进行过更新或删除，则此顺序将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能（也不应该）依赖该排序顺序。关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。 ORDER BYorder by column_name[,column_name,…….]; # 按选定列名的值排序， 当然，可以选择多列。 多列时排序的依据，以第一列为主要依据，后面的次之，按照出现的顺序重要性依次降低 DESC:降序排列ORDER BY column_name DESC; DESC关键字只应用到直接位于其前面的列名，。 在多个列上降序排序 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。 ASC:升序排列order by column_name (ASC); #order by 语句后不指定的话，默认即为ASC 规则同DESC。 关于字符的排序规则：区分大小写和排序顺序 在对文本性的数据进行排序时，A与a相同吗？a位于B之前还是位于Z之后？这些问题不是理论问题，其答案取决于数据库如何设置。在字典（dictionary）排序顺序中，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这样做）。 找出最值：使用ORDER BY 与 LIMIT结合，能够找出一个列中最高或最低的值！ ORDER BY子句的位置在给出ORDER BY子句时，应该保证它位于FROM子句之后。如果使用LIMIT，它必须位于ORDER BY之后。使用子句的次序不对将产生错误消息。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解MySQL]]></title>
    <url>%2F2019%2F07%2F20%2F%E4%BA%86%E8%A7%A3MySQL%2F</url>
    <content type="text"><![CDATA[前言​ 东西都忘的差不多了，要捡起来了！该系列作为一个简单的复习回顾，以及本人的总结。如有错误，还请留言指出！共同交流进步。 英语好的同学可直接阅读MySQL官方文档。 数据库基础了解SQL数据库(database)：保存有组织的数据的容器(通常是一个文件 或者一组文件)。 表(table)：某种特定数据类型的结构化清单。存储的是一种类型(one type， not a kind of type)的数据。每个表，表名唯一，用于标识自己。 模式(schema)：关于数据库和表的布局 及特性的信息。 列(column): 表中的一个字段。所有的表都是由一个或多个列组成！正确的将数据分为多列是很重要的。 数据类型(dataType): 所容许的数据的类型。每个列都有相应的数据类型，它限制(仅允许)该类中存储的数据的类型。 行(row): 表中的一个记录。(表中的数据是按行存储的)。 主键(primary key): 一列(或一组列)，其值能够唯一区分表中的每个行。 (题外： InnoDB 默认每个表都必须要有一个主键。自顶主键&gt;第一个非空索引&gt;InnoDB内部生成主键.相对而言，指定自增主键是最划算的做法，这样在插入数据时 索引建立最快！) SQL:Structured Query Language 。结构化查询语言 MySQL简介数据的所有存储、检索、管理和处理实际上是由数据库软件——DBMS（数据库管理系统）完成的。MySQL是一种DBMS，即它是一种数据库软件。 DBMS可分为两类：一类为基于共享文件系统的DBMS，另一类为基于客户机—服务器的DBMS。MySQL即属于后者。 MySQL命令行使用 命令输入在mysql&gt;之后； 命令用 ; 或 \g 结束，换句话说，仅按Enter不执行命令； 输入help或\h获得帮助，也可以输入更多的文本获得特定命令的 帮助（如，输入help select获得使用SELECT语句的帮助）； 输入quit或exit退出命令行实用程序。 使用MySQL连接:主机名(本机为localhost，ip也行)，端口，合法用户名，密码 选择数据库:命令： use 数据库名;必须要先选择一个数据库，才能对其中的数据进行操作 以及对该数据库进行其他操作。 了解数据库与表： 命令：SHOW DATABASES; 显示MySQL服务器上所有可用数据库。 SHOW TABLES;返回当前选择的数据库中可用的表。 SHOW COLUMS FROM table_name;显示表中的列及其相关信息。 DESCRIBE table_name;是SHOW COLUMNS FROM table）name; 的一种快捷方式。 自动增量:在每个行添加到表中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量 其他SHOW语句： SHOW STATUS，用于显示广泛的服务器状态信息； SHOW CREATE DATABASE和SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句； SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限**； SHOW ERRORS和SHOW WARNINGS，用来显示服务器错误或警告消息。 更多SHOW命令 可用 HELP SHOW 命令查看。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL必知必会学习-复习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis官网学习-介绍]]></title>
    <url>%2F2019%2F07%2F20%2FMyBatis%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java线程安全的单例模式实现]]></title>
    <url>%2F2019%2F07%2F18%2FJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[结论对象的创建有两种模式， 一为饿汉式，二为懒汉式 饿汉式：在实例化该对象的同时，该对象就同时new一个自己。通俗的讲，就是 自己是自己的成员变量，且默认直接给自己new出来！需要使用时，自己直接将自己拿出来就好。所以，必然不会存在线程安全问题！ 缺点：类加载即初始化实例，加入实例变量比较多的话，会占用较多的内存。 懒汉式：在需要使用一个对象时，才创建该对象。因此，多线程下就显得不安全了，可能不同的线程都会进来创建，会创建多个该对象。当然也就破坏了单例. 饿汉式(线程安全)static+ 作为成员变量直接初始化12345678910111213public class Single &#123; //直接将自己作为自己的成员变量 且用static修饰，这样就整个类中只有一个该对象了 private static Single instance = new Single(); private Single()&#123; System.out.println("Single: " + System.nanoTime()); &#125; public static Single getInstance()&#123; return instance; &#125;&#125; 利用私有内部工厂：(与上面没啥实质去区别) 1234567891011121314public class Singleton &#123; private Singleton()&#123; System.out.println("Singleton: " + System.nanoTime()); &#125; public static Singleton getInstance()&#123; return SingletonFactory.singletonInstance; &#125; private static class SingletonFactory&#123; private static Singleton singletonInstance = new Singleton(); //开始就给自己new出来 &#125;&#125; 枚举对编程要求较高 1234567891011121314 //枚举本身是final的, 不允许被继承public enum EnumSingle &#123; INSTANCE; EnumSingleton() &#123; System.out.println("INSTANCE will be initialized immediately"); &#125; public static void method() &#123; //调用该方法会主动使用EnumSingle, INSTANCE将会实例化 &#125; public static EnumSingle getInstance() &#123; return INSTANCE; &#125;&#125; 懒汉式基本：synchronized直接锁！1234567891011121314151617public class Single1 &#123; //当然也有static修饰，这样整个类就只有一个该对象存在 private static Single1 instance = null; private Single1()&#123; System.out.println("Single1: " + System.nanoTime()); &#125; /* 1.直接使用synchronized 锁住 必然线程安全，但是效率低 **/ public static synchronized Single1 getInstance()&#123; if(instance == null)&#123; instance = new Single1(); &#125; return instance; &#125;&#125; 改进：Double Check123456789101112131415161718192021222324public class Single &#123; private volatile static Single instance = null; //volatile修饰，保证可见性 private Single()&#123; System.out.println("Single4: " + System.nanoTime()); &#125; public static Single getInstance()&#123; if(instance == null)&#123; // 可能返回还未初始化的变量，(3先于2执行) synchronized (Single.class) &#123; //如果不走第一步的检查，进来就直接锁的话，和直接在方法上加synchronized没啥去别，效率低 if(instance == null)&#123; instance = new Single(); //new Single()有三步要走， //1.memory = allocate() 分配内存 //2.初始化对象 //3.设置Instance指向刚分配的内存地址，此时Instance!= null //2,3步是可以指令重排的，问题也就在这儿 &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <categories>
        <category>Java杂记</category>
      </categories>
      <tags>
        <tag>Java杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring核心技术]]></title>
    <url>%2F2019%2F07%2F18%2FSpring%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[​ 参考文档的本部分涵盖了Spring框架中不可或缺的所有技术。 ​ 其中最重要的是Spring框架的控制反转(IoC)容器。对Spring框架的IoC容器进行彻底的处理之后，紧接着是对Spring面向切面编程(AOP)技术的全方位学习。Spring框架有自己的AOP框架，它在概念上很容易理解，并且成功地解决了Java企业编程中AOP需求的80%的需求点。 ​ 还包含了Spring与AspectJ集成的内容(就特性而言，AspectJ目前是最丰富的，当然也是Java企业级开发中最成熟的AOP实现)。 1.IOC容器​ 本章讨论Spring的反转控制(IoC)容器。 1.1Spring IoC容器与Bean的介绍​ 本章介绍了Spring框架中实现控制反转(IoC)的原理。IoC也称为依赖注入(dependency injection, DI)。这是一个过程，在这个过程中，对象仅通过构造函数参数、工厂方法的参数或 属性 来定义对象实例的依赖关系，在对象实例被构造或者从工厂方法返回后。然后容器在创建bean时注入这些依赖项。这个过程本质上反转了(因此称为控制反转 Inversion of Control)类自身通过类的直接构造方法来控制实例化或定位其自己的依赖的过程。 ​ org.springframework.beans和org.springframework.context包是Spring框架IoC容器的基础。BeanFactory 接口提供了高级的配置机制使管理任何类型的类都变得可能。 ApplicationContext是BeanFactory的替代接口。它增加了： Spring AOP更方便的集成 消息资源处理(用于国际化) 事件发布 应用层特定的上下文，如可在Web应用程序中使用WebApplicationContext 简而言之，BeanFactory提供配置框架和基本功能，而ApplicationContext添加了更多企业级特定的功能，ApplicationContext是BeanFactory的一个完整超集，在本章中仅在描述Spring的IoC容器时使用它。有关使用BeanFactory*而不是ApplicationContext的更多信息，请参见The BeanFactory。 ​ 在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称bean。bean是由Spring IoC容器实例化、组装和管理等等的对象。否则，bean只简单的是应用程序中的许多对象之一。Beans,及其之间的依赖关系反映在容器使用的配置元数据中 1.2 容器概述​ org.springframework.context.ApplicationContext接口代表了Spring IoC容器，被用于实例化，配置并且装配Bean。容器通过读取配置元数据获取关于要实例化、配置和组装哪些对象的指令。配置元数据用XML、Java注释或Java代码呈现出来。它允许你表达组成您应用程序的对象以及这些对象之间复杂的依赖关系。 ​ Spring提供了ApplicationContext接口的几个实现。在独立运行的应用程序中，通常创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML一直是定义配置元数据的传统格式，但是您可以通过提供少量XML配置来声明支持这些额外的元数据格式，从而高告诉容器使用Java注释或代码作为元数据格式。 ​ 在大多数应用程序场景中，不需要明显的用户代码来实例化Spring IoC容器的一个或多个实例。例如，在web应用程序场景中，web.XML文件中使用8行左右的简单样例来描述XML就足够了(请参阅 web应用程序方便的ApplicationContext实例化)。如果使用Spring工具套件 (一个eclipse支持的开发环境)，只需单击几下鼠标或按键，就可以轻松创建这个样板配置。 ​ 下图显示了Spring如何工作的高级视图。你的应用程序类与配置元数据相结合，这样，在创建并初始化ApplicationContext之后，你就拥有了一个完全配置的可执行系统或应用程序。 1.2.1配置元数据​ 正如上述图片所示，Spring IoC容器使用配置元数据的形式。此配置元数据表示作为应用程序开发人员，你告诉Spring容器如何去实例化、配置和组装应用程序中的对象。 ​ 配置元数据通常以简单直观的XML格式呈现，本章的大部分内容都使用这种格式来表达Spring IoC容器的关键概念和特性。 ​ 基于xml的元数据不是惟一允许的配置元数据形式。Spring IoC容器本身与配置元数据的格式完全解耦。现在，许多开发人员为他们的Spring应用程序选择基于java的配置。 ​ 有关在Spring容器中使用其他形式的元数据的信息，请参见: 基于注解的配置：从Spring2.5开始引入 基于Java的配置：从Spring3.0开始引入，Spring JavaConfig项目提供的许多特性成为Spring核心框架的一部分。因此，您可以使用Java而不是XML文件来定义应用程序类外部的bean。要使用这些新特性，请参见 @Configuration, @Bean, @Import, 和@DependsOn注解。 Spring配置包含至少一个bean定义，并且通常包含多个bean，这些Bean容器必须要管理。基于xml的配置元数据将这些bean配置为顶级标签中的标签的元素。Java配置通常在@Configuration类中使用@ Bean注解的方法。 ​ 这些bean定义对应于组成应用程序的实际对象。通常，你定义服务层对象、数据访问对象(DAOs)、表示对象(如Struts动作实例)、基础设施对象(如Hibernate的SessionFactories)、JMS队列等等。通常，不会在容器中配置细粒度的域对象(有点疑问？不是很懂这个概念)，因为通常由DAOs和业务逻辑负责创建和加载域对象。不过，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。参考 Using AspectJ to dependency-inject domain objects with Spring.(在Spring中使用AspectJ来注入域对象) 基于XML的配置元数据的例子 如下： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation="http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;bean id="..." class="..."&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;!--id属性，是一个字符串，用于识别单个Bean定义 --&gt;&lt;!--class属性定义了Bean的类型，通常为完整的合格的类名 --&gt; &lt;bean id="..." class="..."&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans id属性的值引用了对象。本例中没有显示用于引用协作对象的XML。 1.2.2初始化容器提供给ApplicationContext构造函数的位置路径(可以有多个)是资源字符串，允许容器从各种外部资源(如本地文件系统、Java类路径等)加载配置元数据。 12ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");//多个之间用 英文逗号 隔开即可 下面的示例显示了服务层对象(services.xml)配置文件: 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 下面的示例显示了数据获取对象daos.xml文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring官方文档学习-基于5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架概览]]></title>
    <url>%2F2019%2F07%2F18%2FSpring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[Spring框架概览​ Spring让创建Java企业级应用变得更简单.它提供了任何你在企业级环境中使用Java进行开发所需要的东西。同时也支持其他能在JVM上运行的语言，例如Groovy和Kotlin。通知也可很灵活创建任何需求所需要的架构。对于Spring框架5.1来说，SPring需要JDK8及其以上的支持，同时也提供对JDK11的开箱即用的长期支持。 ​ Spring支持很多种应用类型场景。在一个大企业里面，应用通常会存在很长一段时间，这些应用必须运行在JDK以及应用服务器上，他们的更新周期可能会脱离开发者的控制。其他的可能是以一个单独 jar包在内置的服务器上，也可能是在云端运行。现今仍然有许多应用是独立应用，比如批处理等，这些应用不需要运行在服务器上。 1.Spring对我们来说意味着什么？​ 专业术语“Spring”在不同的环境下有不同的意义。它可以被用来指定Spring框架本身，这也是它最开的意义。随着时间过去，其他的Spring项目在Spring框架的基础上建立起来。本参考文档聚焦于基础：即Spring框架本身。 ​ Spring框架被拆分为了许多模块。应用可以自主选择它需要的模块。Spring的核心模块为 核心容器(core container),包括 配置模块 和 依赖注入机制。除此之外，Spring对不同的应用架构提供了许多基础支持，包括 消息，事务数据和持久化 以及web。同时它也包含基于Servlet的SpringMVC web框架，也有平行的 Spring WebFlux反应式的web框架。 ​ (还有一段，用到了JDK9的新概念，暂时不知道是在说啥，有机会再补翻译) 2.Spring与一系列Spring相关框架的历史​ Spring在2003年被提出，作为对早期J2EE规范中的复杂性的响应。虽然有些人认为Java EE和Spring是竞争对手，但Spring实际上是Java EE的补充。Spring编程模型不包含Java EE平台规范;相反，它集成了从EE体系中精心选择的各个规范： Servlet API (JSR 340) WebSocket API (JSR 356) Concurrency Utilities (JSR 236) JSON Binding API (JSR 367) Bean Validation (JSR 303) JPA (JSR 338) JMS (JSR 914) 必要的，也支持 协调事务的JTA/JCA设置 Spring框架同时也支持DI(JSR 330),常用注解(JSR 250)规范。开发者可选择使用上述的而非Spring框架提供的Spring特定机制。 ​ 对于Spring5.0来说，Spring要求至少JavaEE7(Servlet3.1以上，JPA2.1以上)。同时提供开箱即用的集成了更新的API，在Java EE 8(Servlet 4.0, JSON绑定API)运行环境中。这使得Spring与Tomcat 8和Tomcat 9、WebSphere 9和JBoss EAP 7完全兼容。 ​ 随着时间的推移，Java EE在应用程序开发中的角色已经发生了变化。在Java EE和Spring的早期，创建应用程序是为了部署到应用服务器。今天，在Spring Boot的帮助下，应用程序以一种devops和云友好的方式创建，在内嵌的Servlet容器，并且改动也很少。从Spring Framework 5开始，WebFlux应用程序甚至不直接使用Servlet API，并且可以运行在非Servlet容器的服务器上(比如Netty)。 ​ Spring仍让在继续改进与创新。除了Spring框架之外，还有其他项目，比如Spring Boot、Spring Security、Spring Data、Spring Cloud、Spring Batch等等。重要的是，每个项目都有自己的源代码存储库、问题跟踪和发布节奏。可在Spring.io上查看Spring项目的完整列表 3.Spring的设计思想​ 当你学习一个框架时，重要的是不仅要知道它做什么，还要知道它遵循什么原则。以下是Spring框架的指导原则: 在项目应用开发的每个层次上都提供选择。Spring允许你尽可能推迟设计决策。例如，您可以通过配置切换持久性提供者，而无需更改代码。对于许多其他基础设施问题以及与第三方api的集成也是如此。 容纳不同的观点。Spring信奉灵活，并且不对事情应该怎样做发表人任何意见。它在各种不同的层面上支持各种不同的应用 保持强大的向后兼容性。Spring的发展已经被精心的规划管理，以在版本之间强制进行很少的破坏性更改。Spring支持精心选择的JDK版本和第三方库，以方便维护依赖于Spring的应用程序和库。 关心API设计。Spring团队投入了大量的想法和时间来使api更加直观，并将该观点保持在许多本版上。 为代码质量设定高标准。Spring框架非常强调有意义的、及时的和准确的java参考文档。它是极少数可以声明代码结构干净且包之间没有循环依赖关系的项目之一。 4.反馈与贡献​ 对于怎样做之类的问题(questions page )、诊断或调试问题，我们建议使用StackOverflow，并且我们有一个问题页面，列出了说明建议怎样使用。如果你非常确定Spring框架中存在问题，或者想建议一个特性，请使用GitHub Issues。 ​ 如果您心中有一个解决方案或建议的修复，您可以在 Github上提交一个pull request。但是，请记住，除了琐碎的问题外，我们希望在问题跟踪器中归档，您可以在那里进行讨论，并留下记录供将来参考。 ​ 更多详细信息，请参阅在 CONTRIBUTING中提供的指导方针。 5.快速开始​ 如果你刚刚开始使用Spring，你可以通过创建一个基于Spring Boot的应用程序来开始使用Spring框架。Spring Boot提供了一种快速的方法来创建基于Spring的可生产应用程序。它基于Spring框架，支持约定而不是配置，旨在让您尽可能快地启动和运行应用。 ​ 您可以使用start.spring.io生成一个基本项目或遵循 “快速开始” 指南中任意项目，例如 开始构建RESTful Web服务。这些指南不仅更容易理解，而且更专注于任务，其中大多数都是基于Spring Boot的。它们还涵盖了Spring 文件夹中的其他项目，你在解决特定问题时可能需要用到这些项目。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring官方文档学习-基于5.1</tag>
      </tags>
  </entry>
</search>
