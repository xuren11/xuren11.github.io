<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java线程安全的单例模式实现]]></title>
    <url>%2F2019%2F07%2F18%2FJava%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[结论对象的创建有两种模式， 一为饿汉式，二为懒汉式 饿汉式：在实例化该对象的同时，该对象就同时new一个自己。通俗的讲，就是 自己是自己的成员变量，且默认直接给自己new出来！需要使用时，自己直接将自己拿出来就好。所以，必然不会存在线程安全问题！ 缺点：类加载即初始化实例，加入实例变量比较多的话，会占用较多的内存。 懒汉式：在需要使用一个对象时，才创建该对象。因此，多线程下就显得不安全了，可能不同的线程都会进来创建，会创建多个该对象。当然也就破坏了单例. 饿汉式(线程安全)12345678910111213public class Single &#123; //直接将自己作为自己的成员变量 private static Single instance = new Single(); private Single()&#123; System.out.println("Single: " + System.nanoTime()); &#125; public static Single getInstance()&#123; return instance; &#125;&#125; 利用私有内部工厂：(与上面没啥实质去区别) 1234567891011121314public class Singleton &#123; private Singleton()&#123; System.out.println("Singleton: " + System.nanoTime()); &#125; public static Singleton getInstance()&#123; return SingletonFactory.singletonInstance; &#125; private static class SingletonFactory&#123; private static Singleton singletonInstance = new Singleton(); //开始就给自己new出来 &#125;&#125; 枚举对编程要求较高 1234567891011121314 //枚举本身是final的, 不允许被继承public enum EnumSingle &#123; INSTANCE; EnumSingleton() &#123; System.out.println("INSTANCE will be initialized immediately"); &#125; public static void method() &#123; //调用该方法会主动使用EnumSingle, INSTANCE将会实例化 &#125; public static EnumSingle getInstance() &#123; return INSTANCE; &#125;&#125; 懒汉式基本：synchronized直接锁！1234567891011121314151617public class Single1 &#123; private static Single1 instance = null; private Single1()&#123; System.out.println(&quot;Single1: &quot; + System.nanoTime()); &#125; /* 1.直接使用synchronized 锁住 必然线程安全，但是效率低 **/ public static synchronized Single1 getInstance()&#123; if(instance == null)&#123; instance = new Single1(); &#125; return instance; &#125;&#125; 改进：Double Check123456789101112131415161718192021222324public class Single &#123; private volatile static Single instance = null; //volatile修饰，保证可见性 private Single()&#123; System.out.println("Single4: " + System.nanoTime()); &#125; public static Single getInstance()&#123; if(instance == null)&#123; // 可能返回还未初始化的变量，(3先于2执行) synchronized (Single.class) &#123; //如果不走第一步的检查，进来就直接锁的话，和直接在方法上加synchronized没啥去别，效率低 if(instance == null)&#123; instance = new Single(); //new Single()有三步要走， //1.memory = allocate() 分配内存 //2.初始化对象 //3.设置Instance指向刚分配的内存地址，此时Instance!= null //2,3步是可以指令重排的，问题也就在这儿 &#125; &#125; &#125; return instance; &#125;&#125;]]></content>
      <tags>
        <tag>Java杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring核心技术]]></title>
    <url>%2F2019%2F07%2F18%2FSpring%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[​ 参考文档的本部分涵盖了Spring框架中不可或缺的所有技术。 ​ 其中最重要的是Spring框架的控制反转(IoC)容器。对Spring框架的IoC容器进行彻底的处理之后，紧接着是对Spring面向切面编程(AOP)技术的全方位学习。Spring框架有自己的AOP框架，它在概念上很容易理解，并且成功地解决了Java企业编程中AOP需求的80%的需求点。 ​ 还包含了Spring与AspectJ集成的内容(就特性而言，AspectJ目前是最丰富的，当然也是Java企业级开发中最成熟的AOP实现)。 1.IOC容器​ 本章讨论Spring的反转控制(IoC)容器。 1.1Spring IoC容器与Bean的介绍​ 本章介绍了Spring框架中实现控制反转(IoC)的原理。IoC也称为依赖注入(dependency injection, DI)。这是一个过程，在这个过程中，对象仅通过构造函数参数、工厂方法的参数或 属性 来定义对象实例的依赖关系，在对象实例被构造或者从工厂方法返回后。然后容器在创建bean时注入这些依赖项。这个过程本质上反转了(因此称为控制反转 Inversion of Control)类自身通过类的直接构造方法来控制实例化或定位其自己的依赖的过程。 ​ org.springframework.beans和org.springframework.context包是Spring框架IoC容器的基础。BeanFactory 接口提供了高级的配置机制使管理任何类型的类都变得可能。 ApplicationContext是BeanFactory的替代接口。它增加了： Spring AOP更方便的集成 消息资源处理(用于国际化) 事件发布 应用层特定的上下文，如可在Web应用程序中使用WebApplicationContext 简而言之，BeanFactory提供配置框架和基本功能，而ApplicationContext添加了更多企业级特定的功能，ApplicationContext是BeanFactory的一个完整超集，在本章中仅在描述Spring的IoC容器时使用它。有关使用BeanFactory*而不是ApplicationContext的更多信息，请参见The BeanFactory。 ​ 在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称bean。bean是由Spring IoC容器实例化、组装和管理等等的对象。否则，bean只简单的是应用程序中的许多对象之一。Beans,及其之间的依赖关系反映在容器使用的配置元数据中 1.2 容器概述​ org.springframework.context.ApplicationContext接口代表了Spring IoC容器，被用于实例化，配置并且装配Bean。容器通过读取配置元数据获取关于要实例化、配置和组装哪些对象的指令。配置元数据用XML、Java注释或Java代码呈现出来。它允许你表达组成您应用程序的对象以及这些对象之间复杂的依赖关系。 ​ Spring提供了ApplicationContext接口的几个实现。在独立运行的应用程序中，通常创建ClassPathXmlApplicationContext或FileSystemXmlApplicationContext的实例。虽然XML一直是定义配置元数据的传统格式，但是您可以通过提供少量XML配置来声明支持这些额外的元数据格式，从而高告诉容器使用Java注释或代码作为元数据格式。 ​ 在大多数应用程序场景中，不需要明显的用户代码来实例化Spring IoC容器的一个或多个实例。例如，在web应用程序场景中，web.XML文件中使用8行左右的简单样例来描述XML就足够了(请参阅 web应用程序方便的ApplicationContext实例化)。如果使用Spring工具套件 (一个eclipse支持的开发环境)，只需单击几下鼠标或按键，就可以轻松创建这个样板配置。 ​ 下图显示了Spring如何工作的高级视图。你的应用程序类与配置元数据相结合，这样，在创建并初始化ApplicationContext之后，你就拥有了一个完全配置的可执行系统或应用程序。 1.2.1配置元数据​ 正如上述图片所示，Spring IoC容器使用配置元数据的形式。此配置元数据表示作为应用程序开发人员，你告诉Spring容器如何去实例化、配置和组装应用程序中的对象。 ​ 配置元数据通常以简单直观的XML格式呈现，本章的大部分内容都使用这种格式来表达Spring IoC容器的关键概念和特性。 ​ 基于xml的元数据不是惟一允许的配置元数据形式。Spring IoC容器本身与配置元数据的格式完全解耦。现在，许多开发人员为他们的Spring应用程序选择基于java的配置。 ​ 有关在Spring容器中使用其他形式的元数据的信息，请参见: 基于注解的配置：从Spring2.5开始引入 基于Java的配置：从Spring3.0开始引入，Spring JavaConfig项目提供的许多特性成为Spring核心框架的一部分。因此，您可以使用Java而不是XML文件来定义应用程序类外部的bean。要使用这些新特性，请参见 @Configuration, @Bean, @Import, 和@DependsOn注解。 Spring配置包含至少一个bean定义，并且通常包含多个bean，这些Bean容器必须要管理。基于xml的配置元数据将这些bean配置为顶级标签中的标签的元素。Java配置通常在@Configuration类中使用@ Bean注解的方法。 ​ 这些bean定义对应于组成应用程序的实际对象。通常，你定义服务层对象、数据访问对象(DAOs)、表示对象(如Struts动作实例)、基础设施对象(如Hibernate的SessionFactories)、JMS队列等等。通常，不会在容器中配置细粒度的域对象(有点疑问？不是很懂这个概念)，因为通常由DAOs和业务逻辑负责创建和加载域对象。不过，您可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。参考 Using AspectJ to dependency-inject domain objects with Spring.(在Spring中使用AspectJ来注入域对象) 基于XML的配置元数据的例子 如下： 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance xsi:schemaLocation="http://www.springframework.org/schema/beanshttps://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;bean id="..." class="..."&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt;&lt;!--id属性，是一个字符串，用于识别单个Bean定义 --&gt;&lt;!--class属性定义了Bean的类型，通常为完整的合格的类名 --&gt; &lt;bean id="..." class="..."&gt; &lt;!-- collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions go here --&gt;&lt;/beans id属性的值引用了对象。本例中没有显示用于引用协作对象的XML。 1.2.2初始化容器提供给ApplicationContext构造函数的位置路径(可以有多个)是资源字符串，允许容器从各种外部资源(如本地文件系统、Java类路径等)加载配置元数据。 12ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");//多个之间用 英文逗号 隔开即可 下面的示例显示了服务层对象(services.xml)配置文件: 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- services --&gt; &lt;bean id="petStore" class="org.springframework.samples.jpetstore.services.PetStoreServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;property name="itemDao" ref="itemDao"/&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for services go here --&gt;&lt;/beans&gt; 下面的示例显示了数据获取对象daos.xml文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="accountDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;bean id="itemDao" class="org.springframework.samples.jpetstore.dao.jpa.JpaItemDao"&gt; &lt;!-- additional collaborators and configuration for this bean go here --&gt; &lt;/bean&gt; &lt;!-- more bean definitions for data access objects go here --&gt;&lt;/beans&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring官方文档学习-基于5.1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架概览]]></title>
    <url>%2F2019%2F07%2F18%2FSpring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[Spring框架概览​ Spring让创建Java企业级应用变得更简单.它提供了任何你在企业级环境中使用Java进行开发所需要的东西。同时也支持其他能在JVM上运行的语言，例如Groovy和Kotlin。通知也可很灵活创建任何需求所需要的架构。对于Spring框架5.1来说，SPring需要JDK8及其以上的支持，同时也提供对JDK11的开箱即用的长期支持。 ​ Spring支持很多种应用类型场景。在一个大企业里面，应用通常会存在很长一段时间，这些应用必须运行在JDK以及应用服务器上，他们的更新周期可能会脱离开发者的控制。其他的可能是以一个单独 jar包在内置的服务器上，也可能是在云端运行。现今仍然有许多应用是独立应用，比如批处理等，这些应用不需要运行在服务器上。 1.Spring对我们来说意味着什么？​ 专业术语“Spring”在不同的环境下有不同的意义。它可以被用来指定Spring框架本身，这也是它最开的意义。随着时间过去，其他的Spring项目在Spring框架的基础上建立起来。本参考文档聚焦于基础：即Spring框架本身。 ​ Spring框架被拆分为了许多模块。应用可以自主选择它需要的模块。Spring的核心模块为 核心容器(core container),包括 配置模块 和 依赖注入机制。除此之外，Spring对不同的应用架构提供了许多基础支持，包括 消息，事务数据和持久化 以及web。同时它也包含基于Servlet的SpringMVC web框架，也有平行的 Spring WebFlux反应式的web框架。 ​ (还有一段，用到了JDK9的新概念，暂时不知道是在说啥，有机会再补翻译) 2.Spring与一系列Spring相关框架的历史​ Spring在2003年被提出，作为对早期J2EE规范中的复杂性的响应。虽然有些人认为Java EE和Spring是竞争对手，但Spring实际上是Java EE的补充。Spring编程模型不包含Java EE平台规范;相反，它集成了从EE体系中精心选择的各个规范： Servlet API (JSR 340) WebSocket API (JSR 356) Concurrency Utilities (JSR 236) JSON Binding API (JSR 367) Bean Validation (JSR 303) JPA (JSR 338) JMS (JSR 914) 必要的，也支持 协调事务的JTA/JCA设置 Spring框架同时也支持DI(JSR 330),常用注解(JSR 250)规范。开发者可选择使用上述的而非Spring框架提供的Spring特定机制。 ​ 对于Spring5.0来说，Spring要求至少JavaEE7(Servlet3.1以上，JPA2.1以上)。同时提供开箱即用的集成了更新的API，在Java EE 8(Servlet 4.0, JSON绑定API)运行环境中。这使得Spring与Tomcat 8和Tomcat 9、WebSphere 9和JBoss EAP 7完全兼容。 ​ 随着时间的推移，Java EE在应用程序开发中的角色已经发生了变化。在Java EE和Spring的早期，创建应用程序是为了部署到应用服务器。今天，在Spring Boot的帮助下，应用程序以一种devops和云友好的方式创建，在内嵌的Servlet容器，并且改动也很少。从Spring Framework 5开始，WebFlux应用程序甚至不直接使用Servlet API，并且可以运行在非Servlet容器的服务器上(比如Netty)。 ​ Spring仍让在继续改进与创新。除了Spring框架之外，还有其他项目，比如Spring Boot、Spring Security、Spring Data、Spring Cloud、Spring Batch等等。重要的是，每个项目都有自己的源代码存储库、问题跟踪和发布节奏。可在Spring.io上查看Spring项目的完整列表 3.Spring的设计思想​ 当你学习一个框架时，重要的是不仅要知道它做什么，还要知道它遵循什么原则。以下是Spring框架的指导原则: 在项目应用开发的每个层次上都提供选择。Spring允许你尽可能推迟设计决策。例如，您可以通过配置切换持久性提供者，而无需更改代码。对于许多其他基础设施问题以及与第三方api的集成也是如此。 容纳不同的观点。Spring信奉灵活，并且不对事情应该怎样做发表人任何意见。它在各种不同的层面上支持各种不同的应用 保持强大的向后兼容性。Spring的发展已经被精心的规划管理，以在版本之间强制进行很少的破坏性更改。Spring支持精心选择的JDK版本和第三方库，以方便维护依赖于Spring的应用程序和库。 关心API设计。Spring团队投入了大量的想法和时间来使api更加直观，并将该观点保持在许多本版上。 为代码质量设定高标准。Spring框架非常强调有意义的、及时的和准确的java参考文档。它是极少数可以声明代码结构干净且包之间没有循环依赖关系的项目之一。 4.反馈与贡献​ 对于怎样做之类的问题(questions page )、诊断或调试问题，我们建议使用StackOverflow，并且我们有一个问题页面，列出了说明建议怎样使用。如果你非常确定Spring框架中存在问题，或者想建议一个特性，请使用GitHub Issues。 ​ 如果您心中有一个解决方案或建议的修复，您可以在 Github上提交一个pull request。但是，请记住，除了琐碎的问题外，我们希望在问题跟踪器中归档，您可以在那里进行讨论，并留下记录供将来参考。 ​ 更多详细信息，请参阅在 CONTRIBUTING中提供的指导方针。 5.快速开始​ 如果你刚刚开始使用Spring，你可以通过创建一个基于Spring Boot的应用程序来开始使用Spring框架。Spring Boot提供了一种快速的方法来创建基于Spring的可生产应用程序。它基于Spring框架，支持约定而不是配置，旨在让您尽可能快地启动和运行应用。 ​ 您可以使用start.spring.io生成一个基本项目或遵循 “快速开始” 指南中任意项目，例如 开始构建RESTful Web服务。这些指南不仅更容易理解，而且更专注于任务，其中大多数都是基于Spring Boot的。它们还涵盖了Spring 文件夹中的其他项目，你在解决特定问题时可能需要用到这些项目。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring官方文档学习-基于5.1</tag>
      </tags>
  </entry>
</search>
